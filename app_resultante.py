# -*- coding: utf-8 -*-
"""App_resultante.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fxAxg6oGWvyP5E8lyIeC95UDlo3Wsi90
"""

# -*- coding: utf-8 -*-
# app_temblor.py

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt, welch
from fpdf import FPDF
from datetime import datetime, timedelta
import os

# --------- Funciones compartidas ----------

def filtrar_temblor(signal, fs=200):
    b, a = butter(N=4, Wn=[3, 12], btype='bandpass', fs=fs)
    return filtfilt(b, a, signal)

def analizar_temblor_por_ventanas(signal, eje, fs=200, ventana_seg=2):
    signal = signal.dropna().to_numpy()
    signal_filtrada = filtrar_temblor(signal, fs)
    tama√±o_ventana = int(fs * ventana_seg)
    num_ventanas = len(signal_filtrada) // tama√±o_ventana
    resultados = []
    for i in range(num_ventanas):
        segmento = signal_filtrada[i*tama√±o_ventana:(i+1)*tama√±o_ventana]
        if len(segmento) < tama√±o_ventana:
            continue
        f, Pxx = welch(segmento, fs=fs, nperseg=tama√±o_ventana)
        freq_dominante = f[np.argmax(Pxx)]
        if eje in ['Acel_X', 'Acel_Y', 'Acel_Z']:
            segmento = segmento * 9.81
        varianza = np.var(segmento)
        rms = np.sqrt(np.mean(segmento**2))
        amplitud = np.max(segmento) - np.min(segmento)
        resultados.append({
            'Frecuencia Dominante (Hz)': freq_dominante,
            'Varianza (m2/s4)': varianza,
            'RMS (m/s2)': rms,
            'Amplitud Temblor (g)': amplitud
        })
    return pd.DataFrame(resultados)

def crear_grafico(df, nombre, archivo="grafico_resumen.png"):
    resumen = df.groupby('Condicion')[['Frecuencia Dominante (Hz)', 'Varianza (m2/s4)', 'RMS (m/s2)', 'Amplitud Temblor (cm)']].mean()
    resumen.plot(kind='bar', figsize=(10, 6))
    plt.title(f"Comparaci√≥n de Medidas - {nombre}")
    plt.ylabel("Valor")
    plt.xticks(rotation=0)
    plt.tight_layout()
    plt.savefig(archivo)
    plt.close()

# ------------------ Modo principal --------------------

st.title("üß† An√°lisis de Temblor")
opcion = st.sidebar.radio("Selecciona una opci√≥n:", ["1Ô∏è‚É£ An√°lisis de una medici√≥n", "2Ô∏è‚É£ Comparar dos mediciones"])

if opcion == "1Ô∏è‚É£ An√°lisis de una medici√≥n":
        # -*- coding: utf-8 -*-
        # app_temblor.py

       import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt, welch
from fpdf import FPDF
from datetime import datetime, timedelta

# --------- Funciones auxiliares ----------

def filtrar_temblor(signal, fs=200):
    b, a = butter(N=4, Wn=[3, 12], btype='bandpass', fs=fs)
    return filtfilt(b, a, signal)

def calcular_resultante(df):
    return np.sqrt(df['Acel_X']**2 + df['Acel_Y']**2 + df['Acel_Z']**2)

def analizar_temblor_resultante(df, fs=200, ventana_seg=2):
    signal = df.dropna().to_numpy()
    signal_filtrada = filtrar_temblor(signal, fs)

    tama√±o_ventana = int(fs * ventana_seg)
    num_ventanas = len(signal_filtrada) // tama√±o_ventana
    resultados = []

    for i in range(num_ventanas):
        segmento = signal_filtrada[i*tama√±o_ventana:(i+1)*tama√±o_ventana]
        if len(segmento) < tama√±o_ventana:
            continue

        f, Pxx = welch(segmento, fs=fs, nperseg=tama√±o_ventana)
        freq_dominante = f[np.argmax(Pxx)]

        segmento_m_s2 = segmento * 9.81
        varianza = np.var(segmento_m_s2)
        rms = np.sqrt(np.mean(segmento_m_s2**2))

        resultados.append({
            'Frecuencia Dominante (Hz)': freq_dominante,
            'Varianza (m2/s4)': varianza,
            'RMS (m/s2)': rms,
        })

    return pd.DataFrame(resultados)

def diagnosticar(df_amp_freq):
    def max_amp(test): return df_amp_freq[df_amp_freq['Test'] == test]['Amplitud Media (cm)'].max()
    def mean_freq(test): return df_amp_freq[df_amp_freq['Test'] == test]['Frecuencia Dominante (Hz)'].mean()

    if max_amp('Reposo') > 0.3 and 3 <= mean_freq('Reposo') <= 7:
        return "Probable Parkinson"
    elif (max_amp('Postural') > 0.3 or max_amp('Acci√≥n') > 0.3) and (8 <= mean_freq('Postural') <= 10 or 8 <= mean_freq('Acci√≥n') <= 10):
        return "Probable Temblor Esencial"
    else:
        return "Temblor dentro de par√°metros normales"

def crear_grafico(df, nombre):
    df.plot(x='Test', y=['Frecuencia Dominante (Hz)', 'Varianza (m2/s4)', 'RMS (m/s2)', 'Amplitud Media (cm)'],
            kind='bar', figsize=(10, 6))
    plt.title(f"Resumen de Medidas - {nombre}")
    plt.ylabel("Valor")
    plt.xticks(rotation=0)
    plt.tight_layout()
    plt.savefig("grafico_resumen.png")
    plt.close()

def generar_pdf(nombre_paciente, apellido_paciente, edad, sexo, diag_clinico, mano, dedo, diagnostico_auto, df):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", 'B', 16)
    pdf.cell(200, 10, "Informe de An√°lisis de Temblor", ln=True, align='C')

    pdf.set_font("Arial", size=12)
    pdf.ln(10)
    pdf.cell(200, 10, f"Nombre: {nombre_paciente}", ln=True)
    pdf.cell(200, 10, f"Apellido: {apellido_paciente}", ln=True)
    pdf.cell(200, 10, f"Edad: {edad}", ln=True)
    pdf.cell(200, 10, f"Sexo: {sexo}", ln=True)
    pdf.cell(200, 10, f"Diagn√≥stico cl√≠nico: {diag_clinico or 'Sin diagn√≥stico previo'}", ln=True)
    pdf.cell(200, 10, f"Mano: {mano}", ln=True)
    pdf.cell(200, 10, f"Dedo: {dedo}", ln=True)
    fecha_hora = (datetime.now() - timedelta(hours=3)).strftime("%d/%m/%Y %H:%M")
    pdf.cell(200, 10, f"Fecha y hora: {fecha_hora}", ln=True)

    pdf.ln(5)
    pdf.image("grafico_resumen.png", x=10, w=180)

    pdf.ln(5)
    pdf.set_font("Arial", 'B', 10)
    pdf.cell(30, 10, "Test", 1)
    pdf.cell(40, 10, "Frecuencia (Hz)", 1)
    pdf.cell(40, 10, "Varianza", 1)
    pdf.cell(40, 10, "RMS", 1)
    pdf.cell(40, 10, "Amplitud Media (cm)", 1)
    pdf.ln(10)

    pdf.set_font("Arial", size=9)
    for _, row in df.iterrows():
        pdf.cell(30, 10, row['Test'], 1)
        pdf.cell(40, 10, f"{row['Frecuencia Dominante (Hz)']:.2f}", 1)
        pdf.cell(40, 10, f"{row['Varianza (m2/s4)']:.4f}", 1)
        pdf.cell(40, 10, f"{row['RMS (m/s2)']:.4f}", 1)
        pdf.cell(40, 10, f"{row['Amplitud Media (cm)']:.2f}", 1)
        pdf.ln(10)

    pdf.ln(10)
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(200, 10, "Interpretaci√≥n cl√≠nica:", ln=True)
    pdf.set_font("Arial", size=11)
    pdf.multi_cell(0, 8, """
Este informe analiza tres tipos de temblores: en reposo, postural y de acci√≥n.

Los valores de referencia considerados son:
- Temblor Parkinsoniano: 3-6 Hz en reposo.
- Temblor Esencial: 8-10 Hz en acci√≥n o postura.

Amplitudes mayores a 0.3 cm pueden ser cl√≠nicamente relevantes.

Varianza (m2/s4):
- Normal: 0.001‚Äì0.1
- Temblor leve: 0.1‚Äì0.5
- Patol√≥gico: 1‚Äì10

RMS (m/s2):
- Normal: < 0.5
- PK leve: 0.5‚Äì1.5
- TE severo: 2‚Äì3 o m√°s

La clasificaci√≥n autom√°tica es orientativa.
    """)
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(200, 10, f"Diagn√≥stico autom√°tico: {diagnostico_auto}", ln=True)

    filename = f"{nombre_paciente}_informe_temblor.pdf"
    pdf.output(filename)
    return filename

        # ----------- INTERFAZ STREAMLIT ------------

        st.title("üß† An√°lisis de Temblor")
        st.write("Sube los tres archivos CSV correspondientes a las pruebas de Reposo, Postural y Acci√≥n.")

        if all(uploaded_files.values()):
    if st.button("Iniciar an√°lisis"):
        mediciones_tests = {}
        datos_personales = None
        resultados = []

        for test, file in uploaded_files.items():
            df = pd.read_csv(file)
            datos_personales = df.iloc[0].to_frame().T
            mediciones = df.iloc[1:][['Acel_X', 'Acel_Y', 'Acel_Z']].apply(pd.to_numeric, errors='coerce')
            mediciones['Resultante'] = calcular_resultante(mediciones)
            amplitud_media = (mediciones[['Acel_X', 'Acel_Y', 'Acel_Z']].max() - mediciones[['Acel_X', 'Acel_Y', 'Acel_Z']].min()).mean() * 9.81 * 0.5  # cm
            analisis = analizar_temblor_resultante(mediciones['Resultante'])
            if not analisis.empty:
                resultado_prom = analisis.mean()
                resultados.append({
                    'Test': test,
                    'Frecuencia Dominante (Hz)': resultado_prom['Frecuencia Dominante (Hz)'],
                    'Varianza (m2/s4)': resultado_prom['Varianza (m2/s4)'],
                    'RMS (m/s2)': resultado_prom['RMS (m/s2)'],
                    'Amplitud Media (cm)': amplitud_media
                })

        df_resultado = pd.DataFrame(resultados)
        crear_grafico(df_resultado, datos_personales.iloc[0]['Nombre'])
        diag = diagnosticar(df_resultado)
        nombre_pdf = generar_pdf(
            datos_personales.iloc[0].get("Nombre", "No especificado"),
            datos_personales.iloc[0].get("Apellido", "No especificado"),
            datos_personales.iloc[0].get("Edad", "No especificado"),
            datos_personales.iloc[0].get("Sexo", "No especificado"),
            datos_personales.iloc[0].get("Diagn√≥stico", ""),
            datos_personales.iloc[0].get("Mano", ""),
            datos_personales.iloc[0].get("Dedo", ""),
            diag,
            df_resultado
        )
        st.success("‚úÖ An√°lisis completado.")
        with open(nombre_pdf, "rb") as f:
            st.download_button("üìÑ Descargar PDF", f, file_name=nombre_pdf, mime="application/pdf")


elif opcion == "2Ô∏è‚É£ Comparar dos mediciones":
    st.write("Sube los 6 archivos CSV: 3 de cada configuraci√≥n del estimulador")

    uploaded_files_conf1 = {}
    uploaded_files_conf2 = {}

    for test in ["Reposo", "Postural", "Acci√≥n"]:
        uploaded_files_conf1[test] = st.file_uploader(f"Config 1 - Archivo para test de {test}", type="csv", key=f"c1_{test}")
        uploaded_files_conf2[test] = st.file_uploader(f"Config 2 - Archivo para test de {test}", type="csv", key=f"c2_{test}")

    if all(uploaded_files_conf1.values()) and all(uploaded_files_conf2.values()):
        if st.button("Comparar configuraciones"):
            resultados = []
            config_labels = {1: "Configuraci√≥n 1", 2: "Configuraci√≥n 2"}
            datos_personales = None
            config_info = {}

            for i, config_files in enumerate([uploaded_files_conf1, uploaded_files_conf2], start=1):
                for test, file in config_files.items():
                    df = pd.read_csv(file)
                    datos_personales = df.iloc[0].to_frame().T
                    config = f"Config {i}"
                    if config not in config_info:
                        config_info[config] = {k: datos_personales.iloc[0][k] for k in ['Voltaje', 'Frecuencia', 'Corriente'] if k in datos_personales.columns}
                    datos = df.iloc[1:][['Acel_X', 'Acel_Y', 'Acel_Z', 'GiroX', 'GiroY', 'GiroZ']].apply(pd.to_numeric, errors='coerce')
                    for eje in datos.columns:
                        df_proc = analizar_temblor_por_ventanas(datos[eje], eje, fs=50)
                        if not df_proc.empty:
                            prom = df_proc.mean(numeric_only=True)
                            freq = prom['Frecuencia Dominante (Hz)']
                            amp_g = prom['Amplitud Temblor (g)']
                            amp_cm = (amp_g * 981) / ((2 * np.pi * freq) ** 2) if freq > 0 else 0.0
                            resultados.append({
                                'Condicion': f"{config_labels[i]} - {test}",
                                'Eje': eje,
                                'Frecuencia Dominante (Hz)': round(freq, 2),
                                'Varianza (m2/s4)': round(prom['Varianza (m2/s4)'], 4),
                                'RMS (m/s2)': round(prom['RMS (m/s2)'], 4),
                                'Amplitud Temblor (cm)': round(amp_cm, 2)
                            })

            df_final = pd.DataFrame(resultados)
            st.dataframe(df_final)

            crear_grafico(df_final, datos_personales['Nombre'].values[0], archivo="comparacion_temblor.png")

            # Evaluaci√≥n simple: menor RMS promedio general
            resumen = df_final.groupby('Condicion')[['RMS (m/s2)', 'Varianza (m2/s4)', 'Amplitud Temblor (cm)']].mean()
            mejor = resumen['RMS (m/s2)'].idxmin()

            st.success(f"La mejor configuraci√≥n en base a menor RMS promedio es: {mejor}")

            with open("comparacion_temblor.png", "rb") as f:
                st.download_button("üìà Descargar gr√°fico de comparaci√≥n", f, file_name="comparacion_temblor.png")