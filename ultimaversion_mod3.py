# -*- coding: utf-8 -*-
"""UltimaVersion-Mod3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17dRMywVM0Rc25rlrcOy53xb8KA3kRF91
"""

¡Absolutamente! Mis disculpas por no recordar ese detalle crucial de nuestro flujo de trabajo. Tienes toda la razón.

El objetivo es que el médico utilice la Opción 2 para comparar mediciones y luego, una vez que haya decidido qué conjunto de 3 mediciones (Reposo, Postural, Acción) es el más relevante, use la Opción 3 para obtener una única predicción de diagnóstico basada en ese conjunto específico, sin importar a qué mano correspondan.

He modificado la Opción 3 para reflejar esto:

Eliminación de la distinción por mano en la carga de archivos: Ahora solo hay 3 campos de carga genéricos (Reposo, Postural, Acción).
Una única predicción: El modelo calculará las métricas de temblor a partir de estos 3 archivos y generará una sola predicción de diagnóstico.
Ajuste en la extracción de datos del paciente: La información como "mano_medida" y "dedo_medido" se extraerá del primer archivo cargado (Reposo), si está disponible. Esto será lo que aparezca en el informe PDF.
Ajuste en el PDF: El informe PDF reflejará un análisis y una predicción únicos, sin divisiones por "Mano Derecha" o "Mano Izquierda", pero sí indicará la "Mano Medida" si se encuentra en los metadatos.
Aquí tienes el código actualizado:

Python

import streamlit as st
import pandas as pd
import numpy as np
from scipy.signal import welch, butter, filtfilt
from scipy.integrate import simps # Aunque simps no se usa actualmente, se mantuvo del contexto previo
import joblib
import io
import matplotlib.pyplot as plt
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image as RImage
from reportlab.lib import colors
import os
import tempfile # Para guardar gráficos temporalmente para el PDF

# --- Configuración global de la duración de la ventana ---
ventana_duracion_seg = 2

# --- Inicializar una variable en el estado de sesión para controlar el reinicio ---
if "reiniciar" not in st.session_state:
    st.session_state.reiniciar = False

# --- CSS Styling ---
st.markdown("""
    <style>
    /* Oculta el texto 'Limit 200MB per file • CSV' */
    div[data-testid="stFileUploaderDropzoneInstructions"] {
        display: none !important;
    }

    div[data-testid="stFileUploader"] button[kind="secondary"] {
        visibility: hidden;
    }
    div[data-testid="stFileUploader"] button[kind="secondary"]::before {
        float: right;
        margin-right: 0;
        content: "Cargar archivos";
        visibility: visible;
        display: inline-block;
        background-color: #FF5722;
        color: white;
        padding: 0.5em 1em;
        border-radius: 6px;
        border: 2px solid white;
        cursor: pointer;
    }
    /* Alinea todo a la derecha */
    div[data-testid="stFileUploader"] > div:first-child {
        display: flex;
        justify-content: flex-end;
        align-items: center;
    }
    div[data-testid="stFileUploader"] > div {
        display: flex;
        justify-content: flex-end;
        align-items: center;
    }
    </style>
""", unsafe_allow_html=True)

# --- Función para manejar el reinicio ---
def manejar_reinicio():
    if st.session_state.get("reiniciar", False):
        st.session_state.clear()
        st.experimental_rerun()

# Llamada a manejar_reinicio al inicio de la aplicación
manejar_reinicio()

# --- Funciones de Análisis de Temblor - VERSIÓN AVANZADA (Para TODAS las Opciones) ---
def filtrar_temblor_avanzado(signal, fs=100):
    """Filtra la señal con un filtro pasa banda (1-15 Hz) para el análisis avanzado."""
    b, a = butter(N=4, Wn=[1, 15], btype='bandpass', fs=fs)
    return filtfilt(b, a, signal)

def q_to_matrix(q):
    """Convierte un cuaternión a una matriz de rotación 3x3."""
    w, x, y, z = q
    return np.array([
        [1 - 2*(y**2 + z**2),         2*(x*y - z*w),           2*(x*z + y*w)],
        [2*(x*y + z*w),               1 - 2*(x**2 + z**2),      2*(y*z + x*w)], # Corregido 2*(y*z - x*w) -> 2*(y*z + x*w) (típico para q_to_matrix)
        [2*(x*z - y*w),               2*(y*z + x*w),           1 - 2*(x**2 + y**2)]
    ])

def analizar_temblor_por_ventanas_avanzado(df_input, fs=100, ventana_seg=ventana_duracion_seg):
    """
    Analiza las métricas de temblor (Frecuencia Dominante, RMS, Amplitud)
    usando aceleración lineal compensada por gravedad, asumiendo que los
    cuaterniones (qW, qX, qY, qZ) ya están presentes en df_input.
    """
    # Identificar columnas de aceleración
    acc_cols_candidate = [col for col in ['Acc_X', 'Acc_Y', 'Acc_Z', 'Acel_X', 'Acel_Y', 'Acel_Z'] if col in df_input.columns]

    if len(acc_cols_candidate) >= 3:
        # Priorizar 'Acc' si existe un conjunto completo
        if 'Acc_X' in acc_cols_candidate and 'Acc_Y' in acc_cols_candidate and 'Acc_Z' in acc_cols_candidate:
            acc_cols = ['Acc_X', 'Acc_Y', 'Acc_Z']
        elif 'Acel_X' in acc_cols_candidate and 'Acel_Y' in acc_cols_candidate and 'Acel_Z' in acc_cols_candidate:
            acc_cols = ['Acel_X', 'Acel_Y', 'Acel_Z']
        else: # Not all 3 are present for either Acc or Acel
            st.error("No se encontraron 3 columnas completas para aceleración (Acc_X/Y/Z o Acel_X/Y/Z).")
            return pd.DataFrame(), pd.DataFrame()
    else:
        st.error("No se encontraron columnas de aceleración (Acc_X/Y/Z o Acel_X/Y/Z).")
        return pd.DataFrame(), pd.DataFrame()

    # Identificar columnas de cuaterniones
    quat_cols = [col for col in ['qW', 'qX', 'qY', 'qZ'] if col in df_input.columns]

    if len(quat_cols) == 4:
        # st.info("Columnas de cuaterniones (qW, qX, qY, qZ) encontradas. Usando cuaterniones pre-calculados.")
        pass # No mostrar este mensaje en cada llamada para no saturar
    else:
        st.error("No se encontraron las columnas de cuaterniones (qW, qX, qY, qZ) en el archivo CSV. La compensación de gravedad no se puede realizar sin ellos. Asegúrate de que tus archivos CSV las contengan.")
        return pd.DataFrame(), pd.DataFrame()

    # Combinar columnas necesarias y eliminar NaNs
    df = df_input[acc_cols + quat_cols].dropna()

    if df.empty:
        st.warning("El DataFrame está vacío después de eliminar NaNs para el análisis avanzado.")
        return pd.DataFrame(), pd.DataFrame()

    acc = df[acc_cols].to_numpy()
    Q = df[quat_cols].to_numpy()

    if acc.shape[1] != 3 or Q.shape[1] != 4:
        st.error("Los datos de aceleración no tienen 3 ejes o los cuaterniones no tienen 4 componentes.")
        return pd.DataFrame(), pd.DataFrame()

    linear_accelerations_magnitude = []
    g_world_vector = np.array([0.0, 0.0, 9.81]) # Vector de gravedad en el sistema de coordenadas global

    for i in range(len(acc)):
        q = Q[i]
        acc_measured = acc[i]

        # Rotar el vector de gravedad del mundo al marco del sensor
        # Esto es equivalente a R_S_W @ g_W donde R_S_W es la rotación de mundo a sensor
        # Si 'q' es la rotación del sensor al mundo (q_S_W), entonces la rotación del mundo al sensor es q_S_W.inverse()
        # Usamos q_to_matrix(q).T para obtener R_W_S (World to Sensor) si q es S_W (Sensor to World)
        # O si q_to_matrix(q) ya es R_S_W, entonces es directa. Asumo q_to_matrix(q) es R_W_S (Sensor to World)
        # Si q es el cuaternión de WORLD a BODY, entonces R_W_B @ g_W
        # Lo más común es que el cuaternión represente la orientación del cuerpo con respecto al mundo.
        # Entonces acc_measured (en el marco del cuerpo) = acc_linear_body + gravity_body
        # gravity_body = R_B_W @ g_W. Donde R_B_W es la matriz de rotación del cuerpo al mundo.
        # R_B_W se obtiene de q (si q es de Mundo a Cuerpo).

        # Aquí asumimos que `q` es la rotación de Mundo a Cuerpo (World to Body).
        # Para compensar la gravedad, necesitamos el vector de gravedad en el marco del cuerpo.
        # gravity_in_body_frame = R_W_B @ g_world_vector (si R_W_B es Body to World)
        # O: gravity_in_body_frame = R_B_W @ g_world_vector (si R_B_W es World to Body)
        # q_to_matrix(q) generalmente da la matriz de rotación del mundo al cuerpo (R_B_W).

        R_W_B = q_to_matrix(q) # Asumiendo que esta matriz rota de World a Body
        gravity_in_sensor_frame = R_W_B @ g_world_vector
        linear_acc_sensor_frame = acc_measured - gravity_in_sensor_frame
        linear_accelerations_magnitude.append(np.linalg.norm(linear_acc_sensor_frame))

    movimiento_lineal = np.array(linear_accelerations_magnitude)

    if movimiento_lineal.size == 0:
        st.warning("La señal de aceleración lineal es vacía después de la compensación de gravedad.")
        return pd.DataFrame(), pd.DataFrame()

    señal_filtrada = filtrar_temblor_avanzado(movimiento_lineal, fs)

    resultados_por_ventana = []

    tamaño_ventana = int(fs * ventana_seg)
    if tamaño_ventana <= 0:
        st.warning("El tamaño de ventana es cero o negativo.")
        return pd.DataFrame(), pd.DataFrame()

    noverlap = int(tamaño_ventana * 0.5) # 50% de solapamiento

    # Asegurarse de que haya al menos una ventana completa para el análisis
    if len(señal_filtrada) < tamaño_ventana:
        # Si la señal es más corta que la ventana, analiza la señal completa como una única ventana
        segmento = señal_filtrada
        if segmento.size == 0:
            return pd.DataFrame(), pd.DataFrame()

        segmento = segmento - np.mean(segmento)
        # Asegurar nperseg > 0 para welch
        nperseg_val = len(segmento) if len(segmento) > 0 else 1 # Para evitar error con welch si segmento es muy corto
        f, Pxx = welch(segmento, fs=fs, nperseg=nperseg_val) # Asegurar nperseg adecuado

        freq_dominante = f[np.argmax(Pxx)] if len(Pxx) > 0 else 0.0
        rms = np.sqrt(np.mean(segmento**2)) if segmento.size > 0 else 0.0
        amp_g = (np.max(segmento) - np.min(segmento)) / 2 if segmento.size > 0 else 0.0

        if freq_dominante > 1.5:
            # Formula de Amplitud (de g a cm) - Esta es una aproximación y puede variar
            # 1 g = 9.81 m/s^2
            # Acel = Amplitud_Desplazamiento * (2 * pi * Frecuencia)^2
            # Amplitud_Desplazamiento (m) = Acel (m/s^2) / (2 * pi * Frecuencia)^2
            amp_cm = ((amp_g * 9.81 * 100) / ((2 * np.pi * freq_dominante) ** 2))
        else:
            amp_cm = 0.0 # Si la frecuencia dominante es muy baja, la amplitud se vuelve irrealmente grande.

        resultados_por_ventana.append({
            'Ventana': 0,
            'Frecuencia Dominante (Hz)': freq_dominante,
            'RMS (m/s2)': rms,
            'Amplitud Temblor (g)': amp_g,
            'Amplitud Temblor (cm)': amp_cm
        })
    else:
        for i in range(0, len(señal_filtrada) - tamaño_ventana + 1, noverlap):
            segmento = señal_filtrada[i : i + tamaño_ventana]
            segmento = segmento - np.mean(segmento)

            f, Pxx = welch(segmento, fs=fs, nperseg=tamaño_ventana)
            freq_dominante = f[np.argmax(Pxx)] if len(Pxx) > 0 else 0.0

            rms = np.sqrt(np.mean(segmento**2))
            amp_g = (np.max(segmento) - np.min(segmento)) / 2

            if freq_dominante > 1.5:
                amp_cm = ((amp_g * 9.81 * 100) / ((2 * np.pi * freq_dominante) ** 2))
            else:
                amp_cm = 0.0

            resultados_por_ventana.append({
                'Ventana': i // noverlap,
                'Frecuencia Dominante (Hz)': freq_dominante,
                'RMS (m/s2)': rms,
                'Amplitud Temblor (g)': amp_g,
                'Amplitud Temblor (cm)': amp_cm
            })

    df_por_ventana = pd.DataFrame(resultados_por_ventana)

    if not df_por_ventana.empty:
        promedio = df_por_ventana.mean(numeric_only=True).to_dict()
        df_promedio = pd.DataFrame([{
            'Frecuencia Dominante (Hz)': promedio['Frecuencia Dominante (Hz)'],
            'RMS (m/s2)': promedio['RMS (m/s2)'],
            'Amplitud Temblor (cm)': promedio['Amplitud Temblor (cm)']
        }])
    else:
        df_promedio = pd.DataFrame()

    return df_promedio, df_por_ventana

# --- Función para extraer datos del paciente de un DataFrame ---
def extraer_datos_paciente(df):
    datos = {
        "sexo": "No especificado",
        "edad": 0,
        "mano_medida": "No especificada",
        "dedo_medido": "No especificado"
    }
    if not df.empty:
        # Asegurarse de que las columnas existan y no sean NaN antes de intentar acceder
        if "sexo" in df.columns and pd.notna(df.iloc[0]["sexo"]):
            datos["sexo"] = df.iloc[0]["sexo"]
        if "edad" in df.columns and pd.notna(df.iloc[0]["edad"]):
            try:
                # Intenta convertir a int, aceptando coma como decimal
                datos["edad"] = int(float(str(df.iloc[0]["edad"]).replace(',', '.')))
            except (ValueError, TypeError):
                datos["edad"] = 0
        if "mano_medida" in df.columns and pd.notna(df.iloc[0]["mano_medida"]):
            datos["mano_medida"] = df.iloc[0]["mano_medida"]
        if "dedo_medido" in df.columns and pd.notna(df.iloc[0]["dedo_medido"]):
            datos["dedo_medido"] = df.iloc[0]["dedo_medido"]
    return datos


# --- Funciones para Generar PDF (Adaptadas para el análisis avanzado y Opción 3) ---
def generar_pdf(opcion_seleccionada, data_to_pdf, pdf_buffer):
    doc = SimpleDocTemplate(pdf_buffer, pagesize=letter)
    styles = getSampleStyleSheet()
    story = []

    styles.add(ParagraphStyle(name='TitleStyle', fontSize=18, leading=22, alignment=1, spaceAfter=12))
    styles.add(ParagraphStyle(name='SubtitleStyle', fontSize=14, leading=18, alignment=0, spaceAfter=8))
    styles.add(ParagraphStyle(name='Normal', fontSize=10, leading=12, alignment=0))
    styles.add(ParagraphStyle(name='Bold', fontSize=10, leading=12, alignment=0, fontName='Helvetica-Bold'))
    styles.add(ParagraphStyle(name='PredictionStyle', fontSize=16, leading=20, alignment=1, spaceAfter=12, textColor=colors.darkblue, fontName='Helvetica-Bold'))

    if opcion_seleccionada == "1️⃣ Análisis de una medición":
        title = "Informe de Análisis de Una Medición de Temblor"
        df_promedios = data_to_pdf['df_promedios']
        df_resultados_ventanas = data_to_pdf['df_resultados_ventanas']

        story.append(Paragraph(title, styles['TitleStyle']))
        story.append(Spacer(1, 0.2 * inch))

        story.append(Paragraph("<b>Métricas Promedio de Temblor:</b>", styles['SubtitleStyle']))
        data_promedios = [df_promedios.columns.tolist()] + df_promedios.values.tolist()
        table_promedios = Table(data_promedios, colWidths=[2*inch, 1.5*inch, 1.5*inch])
        table_promedios.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#D3D3D3')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(table_promedios)
        story.append(Spacer(1, 0.2 * inch))

        story.append(Paragraph("<b>Métricas por Ventana:</b>", styles['SubtitleStyle']))
        data_ventanas = [df_resultados_ventanas.columns.tolist()] + df_resultados_ventanas.values.tolist()
        table_ventanas = Table(data_ventanas, colWidths=[1*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch])
        table_ventanas.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#D3D3D3')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(table_ventanas)
        story.append(Spacer(1, 0.5 * inch))

    elif opcion_seleccionada == "2️⃣ Comparar dos mediciones":
        title = "Informe de Comparación de Mediciones de Temblor"
        df_comparacion = data_to_pdf['df_comparacion']
        fig_path = data_to_pdf['fig_path']

        story.append(Paragraph(title, styles['TitleStyle']))
        story.append(Spacer(1, 0.2 * inch))

        story.append(Paragraph("<b>Tabla Comparativa de Métricas de Temblor:</b>", styles['SubtitleStyle']))
        data_comp_table = [df_comparacion.columns.tolist()] + df_comparacion.values.tolist()
        table_comp = Table(data_comp_table, colWidths=[1*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch])
        table_comp.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#D3D3D3')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(table_comp)
        story.append(Spacer(1, 0.2 * inch))

        if fig_path:
            story.append(Paragraph("<b>Comparación Visual de Frecuencia Dominante:</b>", styles['SubtitleStyle']))
            img = RImage(fig_path, width=5.5*inch, height=3.5*inch)
            story.append(img)
            story.append(Spacer(1, 0.2 * inch))


    elif opcion_seleccionada == "3️⃣ Predicción de Diagnóstico":
        datos_paciente = data_to_pdf['datos_paciente']
        resultados_analisis = data_to_pdf['resultados_analisis']
        prediccion_final = data_to_pdf['prediccion_final']
        fig_path = data_to_pdf.get('fig_path')
        fs = data_to_pdf['fs']
        ventana_duracion_seg_val = data_to_pdf['ventana_duracion_seg']

        story.append(Paragraph("Informe de Predicción de Diagnóstico de Temblor", styles['TitleStyle']))
        story.append(Spacer(1, 0.2 * inch))

        # Información del Paciente
        story.append(Paragraph("<b>Datos del Paciente:</b>", styles['SubtitleStyle']))
        paciente_data = []
        if datos_paciente.get('sexo') is not None: paciente_data.append([Paragraph("<b>Sexo:</b>", styles['Bold']), Paragraph(str(datos_paciente['sexo']), styles['Normal'])])
        if datos_paciente.get('edad') is not None: paciente_data.append([Paragraph("<b>Edad:</b>", styles['Bold']), Paragraph(str(datos_paciente['edad']), styles['Normal'])])
        # Solo mostrar mano_medida si está especificada
        if datos_paciente.get('mano_medida') is not None and datos_paciente.get('mano_medida') != "No especificada":
            paciente_data.append([Paragraph("<b>Mano Medida:</b>", styles['Bold']), Paragraph(str(datos_paciente['mano_medida']), styles['Normal'])])
        if datos_paciente.get('dedo_medido') is not None and datos_paciente.get('dedo_medido') != "No especificado":
            paciente_data.append([Paragraph("<b>Dedo Medido:</b>", styles['Bold']), Paragraph(str(datos_paciente['dedo_medido']), styles['Normal'])])

        if paciente_data:
            paciente_table = Table(paciente_data, colWidths=[1.5 * inch, 4.5 * inch])
            paciente_table.setStyle(TableStyle([
                ('ALIGN', (0,0), (-1,-1), 'LEFT'), ('VALIGN', (0,0), (-1,-1), 'TOP'),
                ('LEFTPADDING', (0,0), (-1,-1), 0), ('RIGHTPADDING', (0,0), (-1,-1), 0),
                ('BOTTOMPADDING', (0,0), (-1,-1), 0),
            ]))
            story.append(paciente_table)
        else:
            story.append(Paragraph("No se pudieron extraer datos completos del paciente.", styles['Normal']))
        story.append(Spacer(1, 0.1 * inch))

        # Información de Configuración del Análisis
        story.append(Paragraph("<b>Configuración del Análisis:</b>", styles['SubtitleStyle']))
        config_data = [
            [Paragraph("<b>Frecuencia de Muestreo (Hz):</b>", styles['Bold']), Paragraph(str(fs), styles['Normal'])],
            [Paragraph("<b>Duración de Ventana (seg):</b>", styles['Bold']), Paragraph(str(ventana_duracion_seg_val), styles['Normal'])]
        ]
        config_table = Table(config_data, colWidths=[2.5 * inch, 3.5 * inch])
        config_table.setStyle(TableStyle([
            ('ALIGN', (0,0), (-1,-1), 'LEFT'), ('VALIGN', (0,0), (-1,-1), 'TOP'),
            ('LEFTPADDING', (0,0), (-1,-1), 0), ('RIGHTPADDING', (0,0), (-1,-1), 0),
            ('BOTTOMPADDING', (0,0), (-1,-1), 0),
        ]))
        story.append(config_table)
        story.append(Spacer(1, 0.2 * inch))

        # Gráfico de Análisis
        if fig_path:
            story.append(Paragraph(f"<b>Métricas Comparativas por Test:</b>", styles['SubtitleStyle']))
            img = RImage(fig_path, width=6*inch, height=4*inch)
            story.append(img)
            story.append(Spacer(1, 0.2 * inch))

        # Resultados de Análisis
        story.append(Paragraph(f"<b>Resultados del Análisis Detallado:</b>", styles['SubtitleStyle']))
        data_table = [['Test', 'Frecuencia Dominante (Hz)', 'RMS (m/s2)', 'Amplitud Temblor (cm)']]
        for idx, row in resultados_analisis.iterrows():
            data_table.append([
                row['Test'],
                round(row['Frecuencia Dominante (Hz)'], 3),
                round(row['RMS (m/s2)'], 3),
                round(row['Amplitud Temblor (cm)'], 3)
            ])

        table = Table(data_table, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 1.5*inch])
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#D3D3D3')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(table)
        story.append(Spacer(1, 0.2 * inch))

        # Predicción del Modelo
        story.append(Paragraph("<b>Predicción del Modelo de Machine Learning:</b>", styles['SubtitleStyle']))
        if prediccion_final:
            story.append(Paragraph(f"El modelo predice que el paciente tiene **{prediccion_final}**", styles['PredictionStyle']))
            story.append(Spacer(1, 0.1 * inch))
            story.append(Paragraph("<b>Nota:</b> El diagnóstico clínico final debe considerar este resultado y el cuadro general del paciente.", styles['Normal']))
        else:
            story.append(Paragraph("No se pudo generar una predicción debido a la falta de datos o errores.", styles['Normal']))
        story.append(Spacer(1, 0.5 * inch))

    story.append(Paragraph("------------------------------------------------------------------------------------------------------------------------", styles['Normal']))
    story.append(Paragraph("Este informe ha sido generado automáticamente por la aplicación de análisis de temblor.", styles['Normal']))
    story.append(Paragraph("Fecha de generación: " + pd.Timestamp.now().strftime("%d/%m/%Y %H:%M"), styles['Normal']))

    doc.build(story)
    return pdf_buffer


# --- Inicio del script principal de Streamlit ---
st.set_page_config(layout="wide", page_title="Análisis y Predicción de Temblor")

st.sidebar.title("Menú")
opcion = st.sidebar.radio("Selecciona una opción:", [
    "1️⃣ Análisis de una medición",
    "2️⃣ Comparar dos mediciones",
    "3️⃣ Predicción de Diagnóstico"
])


# --- Lógica de la Opción 1 (USA ANÁLISIS AVANZADO) ---
if opcion == "1️⃣ Análisis de una medición":
    st.title("Análisis de una única medición de temblor")
    st.markdown("Sube un archivo CSV con los datos de aceleración (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z) y **cuaterniones (qW, qX, qY, qZ)** para analizar sus métricas de temblor con compensación de gravedad.")

    uploaded_file = st.file_uploader("Sube tu archivo CSV de aceleración y cuaterniones", type=["csv"])

    if uploaded_file is not None:
        try:
            df = pd.read_csv(uploaded_file, encoding='latin1', decimal=',')
            st.success("Archivo cargado exitosamente.")
            st.dataframe(df.head())

            st.subheader("Configuración del Análisis")
            fs = st.slider("Frecuencia de muestreo (Hz)", min_value=50, max_value=200, value=100, step=10)
            st.info(f"La duración de la ventana de análisis es fija en {ventana_duracion_seg} segundos (para este análisis).")


            if st.button("Analizar Temblor"):
                with st.spinner('Analizando datos...'):
                    # Usamos la función de análisis AVANZADO
                    promedios, df_resultados_ventanas = analizar_temblor_por_ventanas_avanzado(
                        df, fs, ventana_duracion_seg
                    )

                    if not promedios.empty:
                        st.subheader("Métricas Promedio de Temblor")
                        st.dataframe(promedios.round(3))

                        st.subheader("Métricas por Ventana")
                        st.dataframe(df_resultados_ventanas)

                        st.subheader("Visualización de la Frecuencia Dominante por Ventana")
                        fig, ax = plt.subplots(figsize=(10, 5))
                        ax.plot(df_resultados_ventanas['Ventana'], df_resultados_ventanas['Frecuencia Dominante (Hz)'], marker='o')
                        ax.set_xlabel("Número de Ventana")
                        ax.set_ylabel("Frecuencia Dominante (Hz)")
                        ax.set_title("Frecuencia Dominante del Temblor por Ventana")
                        ax.grid(True)
                        st.pyplot(fig)

                        # Generar PDF para Opción 1
                        st.subheader("Generar Informe PDF")
                        pdf_buffer = io.BytesIO()

                        generar_pdf(
                            "1️⃣ Análisis de una medición",
                            {'df_promedios': promedios, 'df_resultados_ventanas': df_resultados_ventanas},
                            pdf_buffer
                        )

                        st.download_button(
                            label="📄 Descargar Informe de Análisis PDF",
                            data=pdf_buffer.getvalue(),
                            file_name="informe_analisis_temblor.pdf",
                            mime="application/pdf"
                        )

                    else:
                        st.warning("No se pudieron calcular las métricas. Revisa tus datos y asegúrate de que contengan columnas de aceleración (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z) y cuaterniones (qW, qX, qY, qZ) válidas.")
        except Exception as e:
            st.error(f"Error al procesar el archivo: {e}")
            st.warning("Asegúrate de que el archivo CSV contenga las columnas requeridas (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ) y que los números usen coma (',') como separador decimal.")


# --- Lógica de la Opción 2 (USA ANÁLISIS AVANZADO) ---
elif opcion == "2️⃣ Comparar dos mediciones":
    st.title("Comparación de dos mediciones de temblor")
    st.markdown("Sube dos conjuntos de archivos CSV (Medición 1 y Medición 2) con datos de aceleración y **cuaterniones** para comparar sus métricas de temblor.")

    st.subheader("Medición 1")
    col1, col2, col3 = st.columns(3)
    with col1:
        reposo1_file = st.file_uploader("Reposo (Medición 1)", type=["csv"], key="reposo1")
    with col2:
        postural1_file = st.file_uploader("Postural (Medición 1)", type=["csv"], key="postural1")
    with col3:
        accion1_file = st.file_uploader("Acción (Medición 1)", type=["csv"], key="accion1")

    st.subheader("Medición 2")
    col4, col5, col6 = st.columns(3)
    with col4:
        reposo2_file = st.file_uploader("Reposo (Medición 2)", type=["csv"], key="reposo2")
    with col5:
        postural2_file = st.file_uploader("Postural (Medición 2)", type=["csv"], key="postural2")
    with col6:
        accion2_file = st.file_uploader("Acción (Medición 2)", type=["csv"], key="accion2")

    fs_comp = st.slider("Frecuencia de muestreo (Hz) para comparación", min_value=50, max_value=200, value=100, step=10, key="fs_comp")

    if st.button("Comparar Mediciones"):
        if (reposo1_file and postural1_file and accion1_file and
            reposo2_file and postural2_file and accion2_file):
            try:
                # Medicion 1
                df_reposo1 = pd.read_csv(reposo1_file, encoding='latin1', decimal=',')
                df_postural1 = pd.read_csv(postural1_file, encoding='latin1', decimal=',')
                df_accion1 = pd.read_csv(accion1_file, encoding='latin1', decimal=',')

                # Usamos la función de análisis AVANZADO
                prom_reposo1, _ = analizar_temblor_por_ventanas_avanzado(df_reposo1, fs_comp, ventana_duracion_seg)
                prom_postural1, _ = analizar_temblor_por_ventanas_avanzado(df_postural1, fs_comp, ventana_duracion_seg)
                prom_accion1, _ = analizar_temblor_por_ventanas_avanzado(df_accion1, fs_comp, ventana_duracion_seg)

                # Medicion 2
                df_reposo2 = pd.read_csv(reposo2_file, encoding='latin1', decimal=',')
                df_postural2 = pd.read_csv(postural2_file, encoding='latin1', decimal=',')
                df_accion2 = pd.read_csv(accion2_file, encoding='latin1', decimal=',')

                # Usamos la función de análisis AVANZADO
                prom_reposo2, _ = analizar_temblor_por_ventanas_avanzado(df_reposo2, fs_comp, ventana_duracion_seg)
                prom_postural2, _ = analizar_temblor_por_ventanas_avanzado(df_postural2, fs_comp, ventana_duracion_seg)
                prom_accion2, _ = analizar_temblor_por_ventanas_avanzado(df_accion2, fs_comp, ventana_duracion_seg)

                # Crear DataFrame para comparación
                comparacion_data = []

                if not prom_reposo1.empty and not prom_reposo2.empty:
                    comparacion_data.append({
                        'Test': 'Reposo',
                        'Frecuencia (Medición 1)': prom_reposo1['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medición 1)': prom_reposo1['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medición 1)': prom_reposo1['Amplitud Temblor (cm)'].iloc[0].round(3),
                        'Frecuencia (Medición 2)': prom_reposo2['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medición 2)': prom_reposo2['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medición 2)': prom_reposo2['Amplitud Temblor (cm)'].iloc[0].round(3)
                    })

                if not prom_postural1.empty and not prom_postural2.empty:
                    comparacion_data.append({
                        'Test': 'Postural',
                        'Frecuencia (Medición 1)': prom_postural1['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medición 1)': prom_postural1['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medición 1)': prom_postural1['Amplitud Temblor (cm)'].iloc[0].round(3),
                        'Frecuencia (Medición 2)': prom_postural2['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medición 2)': prom_postural2['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medición 2)': prom_postural2['Amplitud Temblor (cm)'].iloc[0].round(3)
                    })

                if not prom_accion1.empty and not prom_accion2.empty:
                    comparacion_data.append({
                        'Test': 'Acción',
                        'Frecuencia (Medición 1)': prom_accion1['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medición 1)': prom_accion1['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medición 1)': prom_accion1['Amplitud Temblor (cm)'].iloc[0].round(3),
                        'Frecuencia (Medición 2)': prom_accion2['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medición 2)': prom_accion2['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medición 2)': prom_accion2['Amplitud Temblor (cm)'].iloc[0].round(3)
                    })

                if comparacion_data:
                    df_comparacion = pd.DataFrame(comparacion_data)
                    st.subheader("Tabla Comparativa de Métricas de Temblor")
                    st.dataframe(df_comparacion)

                    # Visualización (ejemplo para frecuencia dominante)
                    st.subheader("Comparación Visual de Métricas")

                    fig, axes = plt.subplots(1, 3, figsize=(18, 6)) # Un subplot para cada métrica

                    metrics = ['Frecuencia', 'RMS', 'Amplitud']
                    ylabels = ['Frecuencia Dominante (Hz)', 'RMS (m/s2)', 'Amplitud Temblor (cm)']

                    for i, metric in enumerate(metrics):
                        df_plot = df_comparacion.set_index('Test')[[f'{metric} (Medición 1)', f'{metric} (Medición 2)']]
                        df_plot.plot(kind='bar', ax=axes[i], rot=45)
                        axes[i].set_title(f'Comparación de {metric} por Test')
                        axes[i].set_ylabel(ylabels[i])
                        axes[i].legend(title='Medición')
                        axes[i].grid(axis='y', linestyle='--', alpha=0.7)

                    plt.tight_layout()
                    st.pyplot(fig)
                    plt.close(fig) # Cierra la figura para liberar memoria

                    # Guardar la figura para el PDF
                    temp_fig_path = os.path.join(tempfile.gettempdir(), "comparacion_metrica.png")
                    fig.savefig(temp_fig_path, dpi=300, bbox_inches='tight')


                    # Generar PDF para Opción 2
                    st.subheader("Generar Informe PDF")
                    pdf_buffer = io.BytesIO()

                    generar_pdf(
                        "2️⃣ Comparar dos mediciones",
                        {'df_comparacion': df_comparacion, 'fig_path': temp_fig_path},
                        pdf_buffer
                    )

                    st.download_button(
                        label="📄 Descargar Informe de Comparación PDF",
                        data=pdf_buffer.getvalue(),
                        file_name="informe_comparacion_temblor.pdf",
                        mime="application/pdf"
                    )
                    # Limpiar archivo temporal
                    os.remove(temp_fig_path)

                else:
                    st.warning("No se pudieron comparar las mediciones. Asegúrate de que todos los archivos estén cargados y sean válidos (contengan columnas Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ).")

            except Exception as e:
                st.error(f"Error al procesar los archivos de comparación: {e}")
                st.warning("Asegúrate de que los archivos CSV contengan las columnas Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ y que los números usen coma (',') como separador decimal.")
        else:
            st.warning("Por favor, sube los seis archivos CSV para realizar la comparación.")


# --- Lógica de la Opción 3: Predicción de Diagnóstico (USA ANÁLISIS AVANZADO) ---
elif opcion == "3️⃣ Predicción de Diagnóstico":
    st.title("🔮 Predicción de Diagnóstico de Temblor")
    st.markdown("Carga los 3 archivos CSV (Reposo, Postural y Acción) que representan una medición de temblor. El modelo realizará una predicción de diagnóstico basada en este conjunto de datos.")
    st.info("Para esta opción, se utilizará el análisis de temblor avanzado que espera **datos de cuaterniones (qW, qX, qY, qZ)** para la compensación de gravedad.")

    # Cargar el modelo entrenado
    try:
        model = joblib.load('tremor_prediction_model.joblib')
        st.success("Modelo de predicción cargado exitosamente.")
    except FileNotFoundError:
        st.error("Error: El archivo 'tremor_prediction_model.joblib' no se encontró. Asegúrate de haber entrenado y guardado el modelo en la misma carpeta que tu script de Streamlit (o la ruta correcta en Colab).")
        model = None
    except Exception as e:
        st.error(f"Error al cargar el modelo: {e}. Asegúrate de que las librerías son compatibles.")
        model = None

    # Uploaders para los 3 archivos genéricos (sin distinción de mano)
    st.markdown("##### Sube tus archivos de medición:")
    col1, col2, col3 = st.columns(3)
    with col1:
        reposo_file = st.file_uploader("Archivo de Reposo", type=["csv"], key="reposo_pred")
    with col2:
        postural_file = st.file_uploader("Archivo Postural", type=["csv"], key="postural_pred")
    with col3:
        accion_file = st.file_uploader("Archivo de Acción", type=["csv"], key="accion_pred")

    st.markdown("---")
    fs_advanced_pred = st.slider("Frecuencia de muestreo (Hz) para el análisis avanzado", min_value=50, max_value=200, value=100, step=10, key="fs_advanced_pred")
    st.info(f"La duración de la ventana de análisis es fija en {ventana_duracion_seg} segundos.")


    if st.button("Realizar Predicción"):
        if model:
            prediccion_final = None
            resultados_analisis = pd.DataFrame() # Para guardar el DataFrame de resultados para el PDF
            datos_paciente_prediccion = {} # Se inicializa aquí para que esté disponible

            if reposo_file and postural_file and accion_file:
                try:
                    st.info(f"Procesando datos para la predicción...")
                    df_reposo = pd.read_csv(reposo_file, encoding='latin1', decimal=',')
                    df_postural = pd.read_csv(postural_file, encoding='latin1', decimal=',')
                    df_accion = pd.read_csv(accion_file, encoding='latin1', decimal=',')

                    # Extraer datos demográficos del paciente de uno de los archivos (ej. reposo)
                    datos_paciente_prediccion = extraer_datos_paciente(df_reposo)

                    # Calcular métricas con la función AVANZADA
                    res_reposo_prom, _ = analizar_temblor_por_ventanas_avanzado(df_reposo, fs_advanced_pred, ventana_duracion_seg)
                    res_postural_prom, _ = analizar_temblor_por_ventanas_avanzado(df_postural, fs_advanced_pred, ventana_duracion_seg)
                    res_accion_prom, _ = analizar_temblor_por_ventanas_avanzado(df_accion, fs_advanced_pred, ventana_duracion_seg)

                    if not (res_reposo_prom.empty or res_postural_prom.empty or res_accion_prom.empty):
                        # Construir el DataFrame de características para la predicción
                        data_para_prediccion = pd.DataFrame([{
                            'sexo': datos_paciente_prediccion.get('sexo'),
                            'edad': datos_paciente_prediccion.get('edad'),
                            # 'mano_medida': datos_paciente_prediccion.get('mano_medida'), # No se usa en el modelo
                            # 'dedo_medido': datos_paciente_prediccion.get('dedo_medido'), # No se usa en el modelo
                            'Frec_Reposo': res_reposo_prom['Frecuencia Dominante (Hz)'].iloc[0],
                            'RMS_Reposo': res_reposo_prom['RMS (m/s2)'].iloc[0],
                            'Amp_Reposo': res_reposo_prom['Amplitud Temblor (cm)'].iloc[0],
                            'Frec_Postural': res_postural_prom['Frecuencia Dominante (Hz)'].iloc[0],
                            'RMS_Postural': res_postural_prom['RMS (m/s2)'].iloc[0],
                            'Amp_Postural': res_postural_prom['Amplitud Temblor (cm)'].iloc[0],
                            'Frec_Accion': res_accion_prom['Frecuencia Dominante (Hz)'].iloc[0],
                            'RMS_Accion': res_accion_prom['RMS (m/s2)'].iloc[0],
                            'Amp_Accion': res_accion_prom['Amplitud Temblor (cm)'].iloc[0]
                        }])

                        prediccion_final = model.predict(data_para_prediccion)[0]

                        # Guardar resultados detallados para el PDF
                        resultados_analisis = pd.DataFrame([
                            {'Test': 'Reposo', 'Frecuencia Dominante (Hz)': res_reposo_prom['Frecuencia Dominante (Hz)'].iloc[0], 'RMS (m/s2)': res_reposo_prom['RMS (m/s2)'].iloc[0], 'Amplitud Temblor (cm)': res_reposo_prom['Amplitud Temblor (cm)'].iloc[0]},
                            {'Test': 'Postural', 'Frecuencia Dominante (Hz)': res_postural_prom['Frecuencia Dominante (Hz)'].iloc[0], 'RMS (m/s2)': res_postural_prom['RMS (m/s2)'].iloc[0], 'Amplitud Temblor (cm)': res_postural_prom['Amplitud Temblor (cm)'].iloc[0]},
                            {'Test': 'Acción', 'Frecuencia Dominante (Hz)': res_accion_prom['Frecuencia Dominante (Hz)'].iloc[0], 'RMS (m/s2)': res_accion_prom['RMS (m/s2)'].iloc[0], 'Amplitud Temblor (cm)': res_accion_prom['Amplitud Temblor (cm)'].iloc[0]}
                        ])

                        # Generar gráfico para esta mano
                        fig, axes = plt.subplots(1, 3, figsize=(18, 6))
                        metrics_to_plot = ['Frecuencia Dominante (Hz)', 'RMS (m/s2)', 'Amplitud Temblor (cm)']
                        titles = ['Frecuencia Dominante', 'RMS', 'Amplitud Temblor']

                        for i, metric in enumerate(metrics_to_plot):
                            values = [
                                resultados_analisis[resultados_analisis['Test'] == 'Reposo'][metric].iloc[0],
                                resultados_analisis[resultados_analisis['Test'] == 'Postural'][metric].iloc[0],
                                resultados_analisis[resultados_analisis['Test'] == 'Acción'][metric].iloc[0]
                            ]
                            axes[i].bar(['Reposo', 'Postural', 'Acción'], values, color=['skyblue', 'lightcoral', 'lightgreen'])
                            axes[i].set_title(f'{titles[i]} por Test')
                            axes[i].set_ylabel(metric)
                            axes[i].grid(axis='y', linestyle='--', alpha=0.7)

                        plt.tight_layout()
                        st.pyplot(fig)
                        plt.close(fig) # Cierra la figura para liberar memoria

                        # Guardar la figura temporalmente para el PDF
                        temp_fig_path = os.path.join(tempfile.gettempdir(), f"metrica_analisis_prediccion.png")
                        fig.savefig(temp_fig_path, dpi=300, bbox_inches='tight')

                        st.success(f"El modelo predice: **{prediccion_final}**")
                    else:
                        st.warning("No se pudieron obtener datos válidos para la predicción. Asegúrate de que los archivos estén completos y contengan las columnas requeridas (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ).")
                except Exception as e:
                    st.error(f"Error al procesar los archivos: {e}")
                    st.warning("Asegúrate de que las columnas en tus archivos CSV de entrada coincidan con las esperadas (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ) y que los datos sean válidos (usando coma decimal).")
            else:
                st.warning("Por favor, sube los tres archivos (Reposo, Postural, Acción) para realizar la predicción.")

            # --- Mostrar Resumen y Botón de Descarga PDF ---
            if prediccion_final is not None and not resultados_analisis.empty:
                st.subheader("Datos del Paciente y Configuración del Análisis")
                st.write("---")
                st.write("**Sexo:**", datos_paciente_prediccion.get('sexo', 'N/A'))
                st.write("**Edad:**", datos_paciente_prediccion.get('edad', 'N/A'))
                # Mostrar mano_medida solo si está especificada
                if datos_paciente_prediccion.get('mano_medida') and datos_paciente_prediccion.get('mano_medida') != "No especificada":
                    st.write("**Mano Medida:**", datos_paciente_prediccion.get('mano_medida'))
                if datos_paciente_prediccion.get('dedo_medido') and datos_paciente_prediccion.get('dedo_medido') != "No especificado":
                    st.write("**Dedo Medido:**", datos_paciente_prediccion.get('dedo_medido'))

                st.write("**Frecuencia de Muestreo (Hz):**", fs_advanced_pred)
                st.write("**Duración de Ventana (seg):**", ventana_duracion_seg)
                st.write("---")

                st.subheader("Resultados Detallados del Análisis")
                st.dataframe(resultados_analisis.round(3))
                st.write("")

                st.subheader("Predicción de Diagnóstico Final")
                st.write(f"El modelo predice: **{prediccion_final}**")
                st.info("Nota: El diagnóstico clínico final debe considerar este resultado y el cuadro general del paciente.")

                # Generar PDF
                st.write("---")
                st.subheader("Generar Informe PDF")
                pdf_buffer = io.BytesIO()

                generar_pdf(
                    "3️⃣ Predicción de Diagnóstico",
                    {
                        'datos_paciente': datos_paciente_prediccion,
                        'resultados_analisis': resultados_analisis,
                        'prediccion_final': prediccion_final,
                        'fig_path': temp_fig_path, # La ruta de la figura generada
                        'fs': fs_advanced_pred,
                        'ventana_duracion_seg': ventana_duracion_seg
                    },
                    pdf_buffer
                )

                st.download_button(
                    label="📄 Descargar Informe de Predicción PDF",
                    data=pdf_buffer.getvalue(),
                    file_name="informe_prediccion_temblor.pdf",
                    mime="application/pdf"
                )
                # Limpiar archivo temporal de gráfico
                if os.path.exists(temp_fig_path):
                    os.remove(temp_fig_path)

        else: # Si el modelo no se cargó
            st.warning("El modelo de predicción no está disponible. Por favor, asegúrate de que el archivo 'tremor_prediction_model.joblib' esté en la carpeta correcta y sin errores.")