# -*- coding: utf-8 -*-
"""UltimaVersion-Mod3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17dRMywVM0Rc25rlrcOy53xb8KA3kRF91
"""

¬°Absolutamente! Mis disculpas por no recordar ese detalle crucial de nuestro flujo de trabajo. Tienes toda la raz√≥n.

El objetivo es que el m√©dico utilice la Opci√≥n 2 para comparar mediciones y luego, una vez que haya decidido qu√© conjunto de 3 mediciones (Reposo, Postural, Acci√≥n) es el m√°s relevante, use la Opci√≥n 3 para obtener una √∫nica predicci√≥n de diagn√≥stico basada en ese conjunto espec√≠fico, sin importar a qu√© mano correspondan.

He modificado la Opci√≥n 3 para reflejar esto:

Eliminaci√≥n de la distinci√≥n por mano en la carga de archivos: Ahora solo hay 3 campos de carga gen√©ricos (Reposo, Postural, Acci√≥n).
Una √∫nica predicci√≥n: El modelo calcular√° las m√©tricas de temblor a partir de estos 3 archivos y generar√° una sola predicci√≥n de diagn√≥stico.
Ajuste en la extracci√≥n de datos del paciente: La informaci√≥n como "mano_medida" y "dedo_medido" se extraer√° del primer archivo cargado (Reposo), si est√° disponible. Esto ser√° lo que aparezca en el informe PDF.
Ajuste en el PDF: El informe PDF reflejar√° un an√°lisis y una predicci√≥n √∫nicos, sin divisiones por "Mano Derecha" o "Mano Izquierda", pero s√≠ indicar√° la "Mano Medida" si se encuentra en los metadatos.
Aqu√≠ tienes el c√≥digo actualizado:

Python

import streamlit as st
import pandas as pd
import numpy as np
from scipy.signal import welch, butter, filtfilt
from scipy.integrate import simps # Aunque simps no se usa actualmente, se mantuvo del contexto previo
import joblib
import io
import matplotlib.pyplot as plt
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image as RImage
from reportlab.lib import colors
import os
import tempfile # Para guardar gr√°ficos temporalmente para el PDF

# --- Configuraci√≥n global de la duraci√≥n de la ventana ---
ventana_duracion_seg = 2

# --- Inicializar una variable en el estado de sesi√≥n para controlar el reinicio ---
if "reiniciar" not in st.session_state:
    st.session_state.reiniciar = False

# --- CSS Styling ---
st.markdown("""
    <style>
    /* Oculta el texto 'Limit 200MB per file ‚Ä¢ CSV' */
    div[data-testid="stFileUploaderDropzoneInstructions"] {
        display: none !important;
    }

    div[data-testid="stFileUploader"] button[kind="secondary"] {
        visibility: hidden;
    }
    div[data-testid="stFileUploader"] button[kind="secondary"]::before {
        float: right;
        margin-right: 0;
        content: "Cargar archivos";
        visibility: visible;
        display: inline-block;
        background-color: #FF5722;
        color: white;
        padding: 0.5em 1em;
        border-radius: 6px;
        border: 2px solid white;
        cursor: pointer;
    }
    /* Alinea todo a la derecha */
    div[data-testid="stFileUploader"] > div:first-child {
        display: flex;
        justify-content: flex-end;
        align-items: center;
    }
    div[data-testid="stFileUploader"] > div {
        display: flex;
        justify-content: flex-end;
        align-items: center;
    }
    </style>
""", unsafe_allow_html=True)

# --- Funci√≥n para manejar el reinicio ---
def manejar_reinicio():
    if st.session_state.get("reiniciar", False):
        st.session_state.clear()
        st.experimental_rerun()

# Llamada a manejar_reinicio al inicio de la aplicaci√≥n
manejar_reinicio()

# --- Funciones de An√°lisis de Temblor - VERSI√ìN AVANZADA (Para TODAS las Opciones) ---
def filtrar_temblor_avanzado(signal, fs=100):
    """Filtra la se√±al con un filtro pasa banda (1-15 Hz) para el an√°lisis avanzado."""
    b, a = butter(N=4, Wn=[1, 15], btype='bandpass', fs=fs)
    return filtfilt(b, a, signal)

def q_to_matrix(q):
    """Convierte un cuaterni√≥n a una matriz de rotaci√≥n 3x3."""
    w, x, y, z = q
    return np.array([
        [1 - 2*(y**2 + z**2),         2*(x*y - z*w),           2*(x*z + y*w)],
        [2*(x*y + z*w),               1 - 2*(x**2 + z**2),      2*(y*z + x*w)], # Corregido 2*(y*z - x*w) -> 2*(y*z + x*w) (t√≠pico para q_to_matrix)
        [2*(x*z - y*w),               2*(y*z + x*w),           1 - 2*(x**2 + y**2)]
    ])

def analizar_temblor_por_ventanas_avanzado(df_input, fs=100, ventana_seg=ventana_duracion_seg):
    """
    Analiza las m√©tricas de temblor (Frecuencia Dominante, RMS, Amplitud)
    usando aceleraci√≥n lineal compensada por gravedad, asumiendo que los
    cuaterniones (qW, qX, qY, qZ) ya est√°n presentes en df_input.
    """
    # Identificar columnas de aceleraci√≥n
    acc_cols_candidate = [col for col in ['Acc_X', 'Acc_Y', 'Acc_Z', 'Acel_X', 'Acel_Y', 'Acel_Z'] if col in df_input.columns]

    if len(acc_cols_candidate) >= 3:
        # Priorizar 'Acc' si existe un conjunto completo
        if 'Acc_X' in acc_cols_candidate and 'Acc_Y' in acc_cols_candidate and 'Acc_Z' in acc_cols_candidate:
            acc_cols = ['Acc_X', 'Acc_Y', 'Acc_Z']
        elif 'Acel_X' in acc_cols_candidate and 'Acel_Y' in acc_cols_candidate and 'Acel_Z' in acc_cols_candidate:
            acc_cols = ['Acel_X', 'Acel_Y', 'Acel_Z']
        else: # Not all 3 are present for either Acc or Acel
            st.error("No se encontraron 3 columnas completas para aceleraci√≥n (Acc_X/Y/Z o Acel_X/Y/Z).")
            return pd.DataFrame(), pd.DataFrame()
    else:
        st.error("No se encontraron columnas de aceleraci√≥n (Acc_X/Y/Z o Acel_X/Y/Z).")
        return pd.DataFrame(), pd.DataFrame()

    # Identificar columnas de cuaterniones
    quat_cols = [col for col in ['qW', 'qX', 'qY', 'qZ'] if col in df_input.columns]

    if len(quat_cols) == 4:
        # st.info("Columnas de cuaterniones (qW, qX, qY, qZ) encontradas. Usando cuaterniones pre-calculados.")
        pass # No mostrar este mensaje en cada llamada para no saturar
    else:
        st.error("No se encontraron las columnas de cuaterniones (qW, qX, qY, qZ) en el archivo CSV. La compensaci√≥n de gravedad no se puede realizar sin ellos. Aseg√∫rate de que tus archivos CSV las contengan.")
        return pd.DataFrame(), pd.DataFrame()

    # Combinar columnas necesarias y eliminar NaNs
    df = df_input[acc_cols + quat_cols].dropna()

    if df.empty:
        st.warning("El DataFrame est√° vac√≠o despu√©s de eliminar NaNs para el an√°lisis avanzado.")
        return pd.DataFrame(), pd.DataFrame()

    acc = df[acc_cols].to_numpy()
    Q = df[quat_cols].to_numpy()

    if acc.shape[1] != 3 or Q.shape[1] != 4:
        st.error("Los datos de aceleraci√≥n no tienen 3 ejes o los cuaterniones no tienen 4 componentes.")
        return pd.DataFrame(), pd.DataFrame()

    linear_accelerations_magnitude = []
    g_world_vector = np.array([0.0, 0.0, 9.81]) # Vector de gravedad en el sistema de coordenadas global

    for i in range(len(acc)):
        q = Q[i]
        acc_measured = acc[i]

        # Rotar el vector de gravedad del mundo al marco del sensor
        # Esto es equivalente a R_S_W @ g_W donde R_S_W es la rotaci√≥n de mundo a sensor
        # Si 'q' es la rotaci√≥n del sensor al mundo (q_S_W), entonces la rotaci√≥n del mundo al sensor es q_S_W.inverse()
        # Usamos q_to_matrix(q).T para obtener R_W_S (World to Sensor) si q es S_W (Sensor to World)
        # O si q_to_matrix(q) ya es R_S_W, entonces es directa. Asumo q_to_matrix(q) es R_W_S (Sensor to World)
        # Si q es el cuaterni√≥n de WORLD a BODY, entonces R_W_B @ g_W
        # Lo m√°s com√∫n es que el cuaterni√≥n represente la orientaci√≥n del cuerpo con respecto al mundo.
        # Entonces acc_measured (en el marco del cuerpo) = acc_linear_body + gravity_body
        # gravity_body = R_B_W @ g_W. Donde R_B_W es la matriz de rotaci√≥n del cuerpo al mundo.
        # R_B_W se obtiene de q (si q es de Mundo a Cuerpo).

        # Aqu√≠ asumimos que `q` es la rotaci√≥n de Mundo a Cuerpo (World to Body).
        # Para compensar la gravedad, necesitamos el vector de gravedad en el marco del cuerpo.
        # gravity_in_body_frame = R_W_B @ g_world_vector (si R_W_B es Body to World)
        # O: gravity_in_body_frame = R_B_W @ g_world_vector (si R_B_W es World to Body)
        # q_to_matrix(q) generalmente da la matriz de rotaci√≥n del mundo al cuerpo (R_B_W).

        R_W_B = q_to_matrix(q) # Asumiendo que esta matriz rota de World a Body
        gravity_in_sensor_frame = R_W_B @ g_world_vector
        linear_acc_sensor_frame = acc_measured - gravity_in_sensor_frame
        linear_accelerations_magnitude.append(np.linalg.norm(linear_acc_sensor_frame))

    movimiento_lineal = np.array(linear_accelerations_magnitude)

    if movimiento_lineal.size == 0:
        st.warning("La se√±al de aceleraci√≥n lineal es vac√≠a despu√©s de la compensaci√≥n de gravedad.")
        return pd.DataFrame(), pd.DataFrame()

    se√±al_filtrada = filtrar_temblor_avanzado(movimiento_lineal, fs)

    resultados_por_ventana = []

    tama√±o_ventana = int(fs * ventana_seg)
    if tama√±o_ventana <= 0:
        st.warning("El tama√±o de ventana es cero o negativo.")
        return pd.DataFrame(), pd.DataFrame()

    noverlap = int(tama√±o_ventana * 0.5) # 50% de solapamiento

    # Asegurarse de que haya al menos una ventana completa para el an√°lisis
    if len(se√±al_filtrada) < tama√±o_ventana:
        # Si la se√±al es m√°s corta que la ventana, analiza la se√±al completa como una √∫nica ventana
        segmento = se√±al_filtrada
        if segmento.size == 0:
            return pd.DataFrame(), pd.DataFrame()

        segmento = segmento - np.mean(segmento)
        # Asegurar nperseg > 0 para welch
        nperseg_val = len(segmento) if len(segmento) > 0 else 1 # Para evitar error con welch si segmento es muy corto
        f, Pxx = welch(segmento, fs=fs, nperseg=nperseg_val) # Asegurar nperseg adecuado

        freq_dominante = f[np.argmax(Pxx)] if len(Pxx) > 0 else 0.0
        rms = np.sqrt(np.mean(segmento**2)) if segmento.size > 0 else 0.0
        amp_g = (np.max(segmento) - np.min(segmento)) / 2 if segmento.size > 0 else 0.0

        if freq_dominante > 1.5:
            # Formula de Amplitud (de g a cm) - Esta es una aproximaci√≥n y puede variar
            # 1 g = 9.81 m/s^2
            # Acel = Amplitud_Desplazamiento * (2 * pi * Frecuencia)^2
            # Amplitud_Desplazamiento (m) = Acel (m/s^2) / (2 * pi * Frecuencia)^2
            amp_cm = ((amp_g * 9.81 * 100) / ((2 * np.pi * freq_dominante) ** 2))
        else:
            amp_cm = 0.0 # Si la frecuencia dominante es muy baja, la amplitud se vuelve irrealmente grande.

        resultados_por_ventana.append({
            'Ventana': 0,
            'Frecuencia Dominante (Hz)': freq_dominante,
            'RMS (m/s2)': rms,
            'Amplitud Temblor (g)': amp_g,
            'Amplitud Temblor (cm)': amp_cm
        })
    else:
        for i in range(0, len(se√±al_filtrada) - tama√±o_ventana + 1, noverlap):
            segmento = se√±al_filtrada[i : i + tama√±o_ventana]
            segmento = segmento - np.mean(segmento)

            f, Pxx = welch(segmento, fs=fs, nperseg=tama√±o_ventana)
            freq_dominante = f[np.argmax(Pxx)] if len(Pxx) > 0 else 0.0

            rms = np.sqrt(np.mean(segmento**2))
            amp_g = (np.max(segmento) - np.min(segmento)) / 2

            if freq_dominante > 1.5:
                amp_cm = ((amp_g * 9.81 * 100) / ((2 * np.pi * freq_dominante) ** 2))
            else:
                amp_cm = 0.0

            resultados_por_ventana.append({
                'Ventana': i // noverlap,
                'Frecuencia Dominante (Hz)': freq_dominante,
                'RMS (m/s2)': rms,
                'Amplitud Temblor (g)': amp_g,
                'Amplitud Temblor (cm)': amp_cm
            })

    df_por_ventana = pd.DataFrame(resultados_por_ventana)

    if not df_por_ventana.empty:
        promedio = df_por_ventana.mean(numeric_only=True).to_dict()
        df_promedio = pd.DataFrame([{
            'Frecuencia Dominante (Hz)': promedio['Frecuencia Dominante (Hz)'],
            'RMS (m/s2)': promedio['RMS (m/s2)'],
            'Amplitud Temblor (cm)': promedio['Amplitud Temblor (cm)']
        }])
    else:
        df_promedio = pd.DataFrame()

    return df_promedio, df_por_ventana

# --- Funci√≥n para extraer datos del paciente de un DataFrame ---
def extraer_datos_paciente(df):
    datos = {
        "sexo": "No especificado",
        "edad": 0,
        "mano_medida": "No especificada",
        "dedo_medido": "No especificado"
    }
    if not df.empty:
        # Asegurarse de que las columnas existan y no sean NaN antes de intentar acceder
        if "sexo" in df.columns and pd.notna(df.iloc[0]["sexo"]):
            datos["sexo"] = df.iloc[0]["sexo"]
        if "edad" in df.columns and pd.notna(df.iloc[0]["edad"]):
            try:
                # Intenta convertir a int, aceptando coma como decimal
                datos["edad"] = int(float(str(df.iloc[0]["edad"]).replace(',', '.')))
            except (ValueError, TypeError):
                datos["edad"] = 0
        if "mano_medida" in df.columns and pd.notna(df.iloc[0]["mano_medida"]):
            datos["mano_medida"] = df.iloc[0]["mano_medida"]
        if "dedo_medido" in df.columns and pd.notna(df.iloc[0]["dedo_medido"]):
            datos["dedo_medido"] = df.iloc[0]["dedo_medido"]
    return datos


# --- Funciones para Generar PDF (Adaptadas para el an√°lisis avanzado y Opci√≥n 3) ---
def generar_pdf(opcion_seleccionada, data_to_pdf, pdf_buffer):
    doc = SimpleDocTemplate(pdf_buffer, pagesize=letter)
    styles = getSampleStyleSheet()
    story = []

    styles.add(ParagraphStyle(name='TitleStyle', fontSize=18, leading=22, alignment=1, spaceAfter=12))
    styles.add(ParagraphStyle(name='SubtitleStyle', fontSize=14, leading=18, alignment=0, spaceAfter=8))
    styles.add(ParagraphStyle(name='Normal', fontSize=10, leading=12, alignment=0))
    styles.add(ParagraphStyle(name='Bold', fontSize=10, leading=12, alignment=0, fontName='Helvetica-Bold'))
    styles.add(ParagraphStyle(name='PredictionStyle', fontSize=16, leading=20, alignment=1, spaceAfter=12, textColor=colors.darkblue, fontName='Helvetica-Bold'))

    if opcion_seleccionada == "1Ô∏è‚É£ An√°lisis de una medici√≥n":
        title = "Informe de An√°lisis de Una Medici√≥n de Temblor"
        df_promedios = data_to_pdf['df_promedios']
        df_resultados_ventanas = data_to_pdf['df_resultados_ventanas']

        story.append(Paragraph(title, styles['TitleStyle']))
        story.append(Spacer(1, 0.2 * inch))

        story.append(Paragraph("<b>M√©tricas Promedio de Temblor:</b>", styles['SubtitleStyle']))
        data_promedios = [df_promedios.columns.tolist()] + df_promedios.values.tolist()
        table_promedios = Table(data_promedios, colWidths=[2*inch, 1.5*inch, 1.5*inch])
        table_promedios.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#D3D3D3')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(table_promedios)
        story.append(Spacer(1, 0.2 * inch))

        story.append(Paragraph("<b>M√©tricas por Ventana:</b>", styles['SubtitleStyle']))
        data_ventanas = [df_resultados_ventanas.columns.tolist()] + df_resultados_ventanas.values.tolist()
        table_ventanas = Table(data_ventanas, colWidths=[1*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch])
        table_ventanas.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#D3D3D3')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(table_ventanas)
        story.append(Spacer(1, 0.5 * inch))

    elif opcion_seleccionada == "2Ô∏è‚É£ Comparar dos mediciones":
        title = "Informe de Comparaci√≥n de Mediciones de Temblor"
        df_comparacion = data_to_pdf['df_comparacion']
        fig_path = data_to_pdf['fig_path']

        story.append(Paragraph(title, styles['TitleStyle']))
        story.append(Spacer(1, 0.2 * inch))

        story.append(Paragraph("<b>Tabla Comparativa de M√©tricas de Temblor:</b>", styles['SubtitleStyle']))
        data_comp_table = [df_comparacion.columns.tolist()] + df_comparacion.values.tolist()
        table_comp = Table(data_comp_table, colWidths=[1*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch])
        table_comp.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#D3D3D3')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(table_comp)
        story.append(Spacer(1, 0.2 * inch))

        if fig_path:
            story.append(Paragraph("<b>Comparaci√≥n Visual de Frecuencia Dominante:</b>", styles['SubtitleStyle']))
            img = RImage(fig_path, width=5.5*inch, height=3.5*inch)
            story.append(img)
            story.append(Spacer(1, 0.2 * inch))


    elif opcion_seleccionada == "3Ô∏è‚É£ Predicci√≥n de Diagn√≥stico":
        datos_paciente = data_to_pdf['datos_paciente']
        resultados_analisis = data_to_pdf['resultados_analisis']
        prediccion_final = data_to_pdf['prediccion_final']
        fig_path = data_to_pdf.get('fig_path')
        fs = data_to_pdf['fs']
        ventana_duracion_seg_val = data_to_pdf['ventana_duracion_seg']

        story.append(Paragraph("Informe de Predicci√≥n de Diagn√≥stico de Temblor", styles['TitleStyle']))
        story.append(Spacer(1, 0.2 * inch))

        # Informaci√≥n del Paciente
        story.append(Paragraph("<b>Datos del Paciente:</b>", styles['SubtitleStyle']))
        paciente_data = []
        if datos_paciente.get('sexo') is not None: paciente_data.append([Paragraph("<b>Sexo:</b>", styles['Bold']), Paragraph(str(datos_paciente['sexo']), styles['Normal'])])
        if datos_paciente.get('edad') is not None: paciente_data.append([Paragraph("<b>Edad:</b>", styles['Bold']), Paragraph(str(datos_paciente['edad']), styles['Normal'])])
        # Solo mostrar mano_medida si est√° especificada
        if datos_paciente.get('mano_medida') is not None and datos_paciente.get('mano_medida') != "No especificada":
            paciente_data.append([Paragraph("<b>Mano Medida:</b>", styles['Bold']), Paragraph(str(datos_paciente['mano_medida']), styles['Normal'])])
        if datos_paciente.get('dedo_medido') is not None and datos_paciente.get('dedo_medido') != "No especificado":
            paciente_data.append([Paragraph("<b>Dedo Medido:</b>", styles['Bold']), Paragraph(str(datos_paciente['dedo_medido']), styles['Normal'])])

        if paciente_data:
            paciente_table = Table(paciente_data, colWidths=[1.5 * inch, 4.5 * inch])
            paciente_table.setStyle(TableStyle([
                ('ALIGN', (0,0), (-1,-1), 'LEFT'), ('VALIGN', (0,0), (-1,-1), 'TOP'),
                ('LEFTPADDING', (0,0), (-1,-1), 0), ('RIGHTPADDING', (0,0), (-1,-1), 0),
                ('BOTTOMPADDING', (0,0), (-1,-1), 0),
            ]))
            story.append(paciente_table)
        else:
            story.append(Paragraph("No se pudieron extraer datos completos del paciente.", styles['Normal']))
        story.append(Spacer(1, 0.1 * inch))

        # Informaci√≥n de Configuraci√≥n del An√°lisis
        story.append(Paragraph("<b>Configuraci√≥n del An√°lisis:</b>", styles['SubtitleStyle']))
        config_data = [
            [Paragraph("<b>Frecuencia de Muestreo (Hz):</b>", styles['Bold']), Paragraph(str(fs), styles['Normal'])],
            [Paragraph("<b>Duraci√≥n de Ventana (seg):</b>", styles['Bold']), Paragraph(str(ventana_duracion_seg_val), styles['Normal'])]
        ]
        config_table = Table(config_data, colWidths=[2.5 * inch, 3.5 * inch])
        config_table.setStyle(TableStyle([
            ('ALIGN', (0,0), (-1,-1), 'LEFT'), ('VALIGN', (0,0), (-1,-1), 'TOP'),
            ('LEFTPADDING', (0,0), (-1,-1), 0), ('RIGHTPADDING', (0,0), (-1,-1), 0),
            ('BOTTOMPADDING', (0,0), (-1,-1), 0),
        ]))
        story.append(config_table)
        story.append(Spacer(1, 0.2 * inch))

        # Gr√°fico de An√°lisis
        if fig_path:
            story.append(Paragraph(f"<b>M√©tricas Comparativas por Test:</b>", styles['SubtitleStyle']))
            img = RImage(fig_path, width=6*inch, height=4*inch)
            story.append(img)
            story.append(Spacer(1, 0.2 * inch))

        # Resultados de An√°lisis
        story.append(Paragraph(f"<b>Resultados del An√°lisis Detallado:</b>", styles['SubtitleStyle']))
        data_table = [['Test', 'Frecuencia Dominante (Hz)', 'RMS (m/s2)', 'Amplitud Temblor (cm)']]
        for idx, row in resultados_analisis.iterrows():
            data_table.append([
                row['Test'],
                round(row['Frecuencia Dominante (Hz)'], 3),
                round(row['RMS (m/s2)'], 3),
                round(row['Amplitud Temblor (cm)'], 3)
            ])

        table = Table(data_table, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 1.5*inch])
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#D3D3D3')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(table)
        story.append(Spacer(1, 0.2 * inch))

        # Predicci√≥n del Modelo
        story.append(Paragraph("<b>Predicci√≥n del Modelo de Machine Learning:</b>", styles['SubtitleStyle']))
        if prediccion_final:
            story.append(Paragraph(f"El modelo predice que el paciente tiene **{prediccion_final}**", styles['PredictionStyle']))
            story.append(Spacer(1, 0.1 * inch))
            story.append(Paragraph("<b>Nota:</b> El diagn√≥stico cl√≠nico final debe considerar este resultado y el cuadro general del paciente.", styles['Normal']))
        else:
            story.append(Paragraph("No se pudo generar una predicci√≥n debido a la falta de datos o errores.", styles['Normal']))
        story.append(Spacer(1, 0.5 * inch))

    story.append(Paragraph("------------------------------------------------------------------------------------------------------------------------", styles['Normal']))
    story.append(Paragraph("Este informe ha sido generado autom√°ticamente por la aplicaci√≥n de an√°lisis de temblor.", styles['Normal']))
    story.append(Paragraph("Fecha de generaci√≥n: " + pd.Timestamp.now().strftime("%d/%m/%Y %H:%M"), styles['Normal']))

    doc.build(story)
    return pdf_buffer


# --- Inicio del script principal de Streamlit ---
st.set_page_config(layout="wide", page_title="An√°lisis y Predicci√≥n de Temblor")

st.sidebar.title("Men√∫")
opcion = st.sidebar.radio("Selecciona una opci√≥n:", [
    "1Ô∏è‚É£ An√°lisis de una medici√≥n",
    "2Ô∏è‚É£ Comparar dos mediciones",
    "3Ô∏è‚É£ Predicci√≥n de Diagn√≥stico"
])


# --- L√≥gica de la Opci√≥n 1 (USA AN√ÅLISIS AVANZADO) ---
if opcion == "1Ô∏è‚É£ An√°lisis de una medici√≥n":
    st.title("An√°lisis de una √∫nica medici√≥n de temblor")
    st.markdown("Sube un archivo CSV con los datos de aceleraci√≥n (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z) y **cuaterniones (qW, qX, qY, qZ)** para analizar sus m√©tricas de temblor con compensaci√≥n de gravedad.")

    uploaded_file = st.file_uploader("Sube tu archivo CSV de aceleraci√≥n y cuaterniones", type=["csv"])

    if uploaded_file is not None:
        try:
            df = pd.read_csv(uploaded_file, encoding='latin1', decimal=',')
            st.success("Archivo cargado exitosamente.")
            st.dataframe(df.head())

            st.subheader("Configuraci√≥n del An√°lisis")
            fs = st.slider("Frecuencia de muestreo (Hz)", min_value=50, max_value=200, value=100, step=10)
            st.info(f"La duraci√≥n de la ventana de an√°lisis es fija en {ventana_duracion_seg} segundos (para este an√°lisis).")


            if st.button("Analizar Temblor"):
                with st.spinner('Analizando datos...'):
                    # Usamos la funci√≥n de an√°lisis AVANZADO
                    promedios, df_resultados_ventanas = analizar_temblor_por_ventanas_avanzado(
                        df, fs, ventana_duracion_seg
                    )

                    if not promedios.empty:
                        st.subheader("M√©tricas Promedio de Temblor")
                        st.dataframe(promedios.round(3))

                        st.subheader("M√©tricas por Ventana")
                        st.dataframe(df_resultados_ventanas)

                        st.subheader("Visualizaci√≥n de la Frecuencia Dominante por Ventana")
                        fig, ax = plt.subplots(figsize=(10, 5))
                        ax.plot(df_resultados_ventanas['Ventana'], df_resultados_ventanas['Frecuencia Dominante (Hz)'], marker='o')
                        ax.set_xlabel("N√∫mero de Ventana")
                        ax.set_ylabel("Frecuencia Dominante (Hz)")
                        ax.set_title("Frecuencia Dominante del Temblor por Ventana")
                        ax.grid(True)
                        st.pyplot(fig)

                        # Generar PDF para Opci√≥n 1
                        st.subheader("Generar Informe PDF")
                        pdf_buffer = io.BytesIO()

                        generar_pdf(
                            "1Ô∏è‚É£ An√°lisis de una medici√≥n",
                            {'df_promedios': promedios, 'df_resultados_ventanas': df_resultados_ventanas},
                            pdf_buffer
                        )

                        st.download_button(
                            label="üìÑ Descargar Informe de An√°lisis PDF",
                            data=pdf_buffer.getvalue(),
                            file_name="informe_analisis_temblor.pdf",
                            mime="application/pdf"
                        )

                    else:
                        st.warning("No se pudieron calcular las m√©tricas. Revisa tus datos y aseg√∫rate de que contengan columnas de aceleraci√≥n (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z) y cuaterniones (qW, qX, qY, qZ) v√°lidas.")
        except Exception as e:
            st.error(f"Error al procesar el archivo: {e}")
            st.warning("Aseg√∫rate de que el archivo CSV contenga las columnas requeridas (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ) y que los n√∫meros usen coma (',') como separador decimal.")


# --- L√≥gica de la Opci√≥n 2 (USA AN√ÅLISIS AVANZADO) ---
elif opcion == "2Ô∏è‚É£ Comparar dos mediciones":
    st.title("Comparaci√≥n de dos mediciones de temblor")
    st.markdown("Sube dos conjuntos de archivos CSV (Medici√≥n 1 y Medici√≥n 2) con datos de aceleraci√≥n y **cuaterniones** para comparar sus m√©tricas de temblor.")

    st.subheader("Medici√≥n 1")
    col1, col2, col3 = st.columns(3)
    with col1:
        reposo1_file = st.file_uploader("Reposo (Medici√≥n 1)", type=["csv"], key="reposo1")
    with col2:
        postural1_file = st.file_uploader("Postural (Medici√≥n 1)", type=["csv"], key="postural1")
    with col3:
        accion1_file = st.file_uploader("Acci√≥n (Medici√≥n 1)", type=["csv"], key="accion1")

    st.subheader("Medici√≥n 2")
    col4, col5, col6 = st.columns(3)
    with col4:
        reposo2_file = st.file_uploader("Reposo (Medici√≥n 2)", type=["csv"], key="reposo2")
    with col5:
        postural2_file = st.file_uploader("Postural (Medici√≥n 2)", type=["csv"], key="postural2")
    with col6:
        accion2_file = st.file_uploader("Acci√≥n (Medici√≥n 2)", type=["csv"], key="accion2")

    fs_comp = st.slider("Frecuencia de muestreo (Hz) para comparaci√≥n", min_value=50, max_value=200, value=100, step=10, key="fs_comp")

    if st.button("Comparar Mediciones"):
        if (reposo1_file and postural1_file and accion1_file and
            reposo2_file and postural2_file and accion2_file):
            try:
                # Medicion 1
                df_reposo1 = pd.read_csv(reposo1_file, encoding='latin1', decimal=',')
                df_postural1 = pd.read_csv(postural1_file, encoding='latin1', decimal=',')
                df_accion1 = pd.read_csv(accion1_file, encoding='latin1', decimal=',')

                # Usamos la funci√≥n de an√°lisis AVANZADO
                prom_reposo1, _ = analizar_temblor_por_ventanas_avanzado(df_reposo1, fs_comp, ventana_duracion_seg)
                prom_postural1, _ = analizar_temblor_por_ventanas_avanzado(df_postural1, fs_comp, ventana_duracion_seg)
                prom_accion1, _ = analizar_temblor_por_ventanas_avanzado(df_accion1, fs_comp, ventana_duracion_seg)

                # Medicion 2
                df_reposo2 = pd.read_csv(reposo2_file, encoding='latin1', decimal=',')
                df_postural2 = pd.read_csv(postural2_file, encoding='latin1', decimal=',')
                df_accion2 = pd.read_csv(accion2_file, encoding='latin1', decimal=',')

                # Usamos la funci√≥n de an√°lisis AVANZADO
                prom_reposo2, _ = analizar_temblor_por_ventanas_avanzado(df_reposo2, fs_comp, ventana_duracion_seg)
                prom_postural2, _ = analizar_temblor_por_ventanas_avanzado(df_postural2, fs_comp, ventana_duracion_seg)
                prom_accion2, _ = analizar_temblor_por_ventanas_avanzado(df_accion2, fs_comp, ventana_duracion_seg)

                # Crear DataFrame para comparaci√≥n
                comparacion_data = []

                if not prom_reposo1.empty and not prom_reposo2.empty:
                    comparacion_data.append({
                        'Test': 'Reposo',
                        'Frecuencia (Medici√≥n 1)': prom_reposo1['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medici√≥n 1)': prom_reposo1['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medici√≥n 1)': prom_reposo1['Amplitud Temblor (cm)'].iloc[0].round(3),
                        'Frecuencia (Medici√≥n 2)': prom_reposo2['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medici√≥n 2)': prom_reposo2['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medici√≥n 2)': prom_reposo2['Amplitud Temblor (cm)'].iloc[0].round(3)
                    })

                if not prom_postural1.empty and not prom_postural2.empty:
                    comparacion_data.append({
                        'Test': 'Postural',
                        'Frecuencia (Medici√≥n 1)': prom_postural1['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medici√≥n 1)': prom_postural1['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medici√≥n 1)': prom_postural1['Amplitud Temblor (cm)'].iloc[0].round(3),
                        'Frecuencia (Medici√≥n 2)': prom_postural2['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medici√≥n 2)': prom_postural2['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medici√≥n 2)': prom_postural2['Amplitud Temblor (cm)'].iloc[0].round(3)
                    })

                if not prom_accion1.empty and not prom_accion2.empty:
                    comparacion_data.append({
                        'Test': 'Acci√≥n',
                        'Frecuencia (Medici√≥n 1)': prom_accion1['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medici√≥n 1)': prom_accion1['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medici√≥n 1)': prom_accion1['Amplitud Temblor (cm)'].iloc[0].round(3),
                        'Frecuencia (Medici√≥n 2)': prom_accion2['Frecuencia Dominante (Hz)'].iloc[0].round(3),
                        'RMS (Medici√≥n 2)': prom_accion2['RMS (m/s2)'].iloc[0].round(3),
                        'Amplitud (Medici√≥n 2)': prom_accion2['Amplitud Temblor (cm)'].iloc[0].round(3)
                    })

                if comparacion_data:
                    df_comparacion = pd.DataFrame(comparacion_data)
                    st.subheader("Tabla Comparativa de M√©tricas de Temblor")
                    st.dataframe(df_comparacion)

                    # Visualizaci√≥n (ejemplo para frecuencia dominante)
                    st.subheader("Comparaci√≥n Visual de M√©tricas")

                    fig, axes = plt.subplots(1, 3, figsize=(18, 6)) # Un subplot para cada m√©trica

                    metrics = ['Frecuencia', 'RMS', 'Amplitud']
                    ylabels = ['Frecuencia Dominante (Hz)', 'RMS (m/s2)', 'Amplitud Temblor (cm)']

                    for i, metric in enumerate(metrics):
                        df_plot = df_comparacion.set_index('Test')[[f'{metric} (Medici√≥n 1)', f'{metric} (Medici√≥n 2)']]
                        df_plot.plot(kind='bar', ax=axes[i], rot=45)
                        axes[i].set_title(f'Comparaci√≥n de {metric} por Test')
                        axes[i].set_ylabel(ylabels[i])
                        axes[i].legend(title='Medici√≥n')
                        axes[i].grid(axis='y', linestyle='--', alpha=0.7)

                    plt.tight_layout()
                    st.pyplot(fig)
                    plt.close(fig) # Cierra la figura para liberar memoria

                    # Guardar la figura para el PDF
                    temp_fig_path = os.path.join(tempfile.gettempdir(), "comparacion_metrica.png")
                    fig.savefig(temp_fig_path, dpi=300, bbox_inches='tight')


                    # Generar PDF para Opci√≥n 2
                    st.subheader("Generar Informe PDF")
                    pdf_buffer = io.BytesIO()

                    generar_pdf(
                        "2Ô∏è‚É£ Comparar dos mediciones",
                        {'df_comparacion': df_comparacion, 'fig_path': temp_fig_path},
                        pdf_buffer
                    )

                    st.download_button(
                        label="üìÑ Descargar Informe de Comparaci√≥n PDF",
                        data=pdf_buffer.getvalue(),
                        file_name="informe_comparacion_temblor.pdf",
                        mime="application/pdf"
                    )
                    # Limpiar archivo temporal
                    os.remove(temp_fig_path)

                else:
                    st.warning("No se pudieron comparar las mediciones. Aseg√∫rate de que todos los archivos est√©n cargados y sean v√°lidos (contengan columnas Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ).")

            except Exception as e:
                st.error(f"Error al procesar los archivos de comparaci√≥n: {e}")
                st.warning("Aseg√∫rate de que los archivos CSV contengan las columnas Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ y que los n√∫meros usen coma (',') como separador decimal.")
        else:
            st.warning("Por favor, sube los seis archivos CSV para realizar la comparaci√≥n.")


# --- L√≥gica de la Opci√≥n 3: Predicci√≥n de Diagn√≥stico (USA AN√ÅLISIS AVANZADO) ---
elif opcion == "3Ô∏è‚É£ Predicci√≥n de Diagn√≥stico":
    st.title("üîÆ Predicci√≥n de Diagn√≥stico de Temblor")
    st.markdown("Carga los 3 archivos CSV (Reposo, Postural y Acci√≥n) que representan una medici√≥n de temblor. El modelo realizar√° una predicci√≥n de diagn√≥stico basada en este conjunto de datos.")
    st.info("Para esta opci√≥n, se utilizar√° el an√°lisis de temblor avanzado que espera **datos de cuaterniones (qW, qX, qY, qZ)** para la compensaci√≥n de gravedad.")

    # Cargar el modelo entrenado
    try:
        model = joblib.load('tremor_prediction_model.joblib')
        st.success("Modelo de predicci√≥n cargado exitosamente.")
    except FileNotFoundError:
        st.error("Error: El archivo 'tremor_prediction_model.joblib' no se encontr√≥. Aseg√∫rate de haber entrenado y guardado el modelo en la misma carpeta que tu script de Streamlit (o la ruta correcta en Colab).")
        model = None
    except Exception as e:
        st.error(f"Error al cargar el modelo: {e}. Aseg√∫rate de que las librer√≠as son compatibles.")
        model = None

    # Uploaders para los 3 archivos gen√©ricos (sin distinci√≥n de mano)
    st.markdown("##### Sube tus archivos de medici√≥n:")
    col1, col2, col3 = st.columns(3)
    with col1:
        reposo_file = st.file_uploader("Archivo de Reposo", type=["csv"], key="reposo_pred")
    with col2:
        postural_file = st.file_uploader("Archivo Postural", type=["csv"], key="postural_pred")
    with col3:
        accion_file = st.file_uploader("Archivo de Acci√≥n", type=["csv"], key="accion_pred")

    st.markdown("---")
    fs_advanced_pred = st.slider("Frecuencia de muestreo (Hz) para el an√°lisis avanzado", min_value=50, max_value=200, value=100, step=10, key="fs_advanced_pred")
    st.info(f"La duraci√≥n de la ventana de an√°lisis es fija en {ventana_duracion_seg} segundos.")


    if st.button("Realizar Predicci√≥n"):
        if model:
            prediccion_final = None
            resultados_analisis = pd.DataFrame() # Para guardar el DataFrame de resultados para el PDF
            datos_paciente_prediccion = {} # Se inicializa aqu√≠ para que est√© disponible

            if reposo_file and postural_file and accion_file:
                try:
                    st.info(f"Procesando datos para la predicci√≥n...")
                    df_reposo = pd.read_csv(reposo_file, encoding='latin1', decimal=',')
                    df_postural = pd.read_csv(postural_file, encoding='latin1', decimal=',')
                    df_accion = pd.read_csv(accion_file, encoding='latin1', decimal=',')

                    # Extraer datos demogr√°ficos del paciente de uno de los archivos (ej. reposo)
                    datos_paciente_prediccion = extraer_datos_paciente(df_reposo)

                    # Calcular m√©tricas con la funci√≥n AVANZADA
                    res_reposo_prom, _ = analizar_temblor_por_ventanas_avanzado(df_reposo, fs_advanced_pred, ventana_duracion_seg)
                    res_postural_prom, _ = analizar_temblor_por_ventanas_avanzado(df_postural, fs_advanced_pred, ventana_duracion_seg)
                    res_accion_prom, _ = analizar_temblor_por_ventanas_avanzado(df_accion, fs_advanced_pred, ventana_duracion_seg)

                    if not (res_reposo_prom.empty or res_postural_prom.empty or res_accion_prom.empty):
                        # Construir el DataFrame de caracter√≠sticas para la predicci√≥n
                        data_para_prediccion = pd.DataFrame([{
                            'sexo': datos_paciente_prediccion.get('sexo'),
                            'edad': datos_paciente_prediccion.get('edad'),
                            # 'mano_medida': datos_paciente_prediccion.get('mano_medida'), # No se usa en el modelo
                            # 'dedo_medido': datos_paciente_prediccion.get('dedo_medido'), # No se usa en el modelo
                            'Frec_Reposo': res_reposo_prom['Frecuencia Dominante (Hz)'].iloc[0],
                            'RMS_Reposo': res_reposo_prom['RMS (m/s2)'].iloc[0],
                            'Amp_Reposo': res_reposo_prom['Amplitud Temblor (cm)'].iloc[0],
                            'Frec_Postural': res_postural_prom['Frecuencia Dominante (Hz)'].iloc[0],
                            'RMS_Postural': res_postural_prom['RMS (m/s2)'].iloc[0],
                            'Amp_Postural': res_postural_prom['Amplitud Temblor (cm)'].iloc[0],
                            'Frec_Accion': res_accion_prom['Frecuencia Dominante (Hz)'].iloc[0],
                            'RMS_Accion': res_accion_prom['RMS (m/s2)'].iloc[0],
                            'Amp_Accion': res_accion_prom['Amplitud Temblor (cm)'].iloc[0]
                        }])

                        prediccion_final = model.predict(data_para_prediccion)[0]

                        # Guardar resultados detallados para el PDF
                        resultados_analisis = pd.DataFrame([
                            {'Test': 'Reposo', 'Frecuencia Dominante (Hz)': res_reposo_prom['Frecuencia Dominante (Hz)'].iloc[0], 'RMS (m/s2)': res_reposo_prom['RMS (m/s2)'].iloc[0], 'Amplitud Temblor (cm)': res_reposo_prom['Amplitud Temblor (cm)'].iloc[0]},
                            {'Test': 'Postural', 'Frecuencia Dominante (Hz)': res_postural_prom['Frecuencia Dominante (Hz)'].iloc[0], 'RMS (m/s2)': res_postural_prom['RMS (m/s2)'].iloc[0], 'Amplitud Temblor (cm)': res_postural_prom['Amplitud Temblor (cm)'].iloc[0]},
                            {'Test': 'Acci√≥n', 'Frecuencia Dominante (Hz)': res_accion_prom['Frecuencia Dominante (Hz)'].iloc[0], 'RMS (m/s2)': res_accion_prom['RMS (m/s2)'].iloc[0], 'Amplitud Temblor (cm)': res_accion_prom['Amplitud Temblor (cm)'].iloc[0]}
                        ])

                        # Generar gr√°fico para esta mano
                        fig, axes = plt.subplots(1, 3, figsize=(18, 6))
                        metrics_to_plot = ['Frecuencia Dominante (Hz)', 'RMS (m/s2)', 'Amplitud Temblor (cm)']
                        titles = ['Frecuencia Dominante', 'RMS', 'Amplitud Temblor']

                        for i, metric in enumerate(metrics_to_plot):
                            values = [
                                resultados_analisis[resultados_analisis['Test'] == 'Reposo'][metric].iloc[0],
                                resultados_analisis[resultados_analisis['Test'] == 'Postural'][metric].iloc[0],
                                resultados_analisis[resultados_analisis['Test'] == 'Acci√≥n'][metric].iloc[0]
                            ]
                            axes[i].bar(['Reposo', 'Postural', 'Acci√≥n'], values, color=['skyblue', 'lightcoral', 'lightgreen'])
                            axes[i].set_title(f'{titles[i]} por Test')
                            axes[i].set_ylabel(metric)
                            axes[i].grid(axis='y', linestyle='--', alpha=0.7)

                        plt.tight_layout()
                        st.pyplot(fig)
                        plt.close(fig) # Cierra la figura para liberar memoria

                        # Guardar la figura temporalmente para el PDF
                        temp_fig_path = os.path.join(tempfile.gettempdir(), f"metrica_analisis_prediccion.png")
                        fig.savefig(temp_fig_path, dpi=300, bbox_inches='tight')

                        st.success(f"El modelo predice: **{prediccion_final}**")
                    else:
                        st.warning("No se pudieron obtener datos v√°lidos para la predicci√≥n. Aseg√∫rate de que los archivos est√©n completos y contengan las columnas requeridas (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ).")
                except Exception as e:
                    st.error(f"Error al procesar los archivos: {e}")
                    st.warning("Aseg√∫rate de que las columnas en tus archivos CSV de entrada coincidan con las esperadas (Acc_X/Acel_X, Acc_Y/Acel_Y, Acc_Z/Acel_Z, qW, qX, qY, qZ) y que los datos sean v√°lidos (usando coma decimal).")
            else:
                st.warning("Por favor, sube los tres archivos (Reposo, Postural, Acci√≥n) para realizar la predicci√≥n.")

            # --- Mostrar Resumen y Bot√≥n de Descarga PDF ---
            if prediccion_final is not None and not resultados_analisis.empty:
                st.subheader("Datos del Paciente y Configuraci√≥n del An√°lisis")
                st.write("---")
                st.write("**Sexo:**", datos_paciente_prediccion.get('sexo', 'N/A'))
                st.write("**Edad:**", datos_paciente_prediccion.get('edad', 'N/A'))
                # Mostrar mano_medida solo si est√° especificada
                if datos_paciente_prediccion.get('mano_medida') and datos_paciente_prediccion.get('mano_medida') != "No especificada":
                    st.write("**Mano Medida:**", datos_paciente_prediccion.get('mano_medida'))
                if datos_paciente_prediccion.get('dedo_medido') and datos_paciente_prediccion.get('dedo_medido') != "No especificado":
                    st.write("**Dedo Medido:**", datos_paciente_prediccion.get('dedo_medido'))

                st.write("**Frecuencia de Muestreo (Hz):**", fs_advanced_pred)
                st.write("**Duraci√≥n de Ventana (seg):**", ventana_duracion_seg)
                st.write("---")

                st.subheader("Resultados Detallados del An√°lisis")
                st.dataframe(resultados_analisis.round(3))
                st.write("")

                st.subheader("Predicci√≥n de Diagn√≥stico Final")
                st.write(f"El modelo predice: **{prediccion_final}**")
                st.info("Nota: El diagn√≥stico cl√≠nico final debe considerar este resultado y el cuadro general del paciente.")

                # Generar PDF
                st.write("---")
                st.subheader("Generar Informe PDF")
                pdf_buffer = io.BytesIO()

                generar_pdf(
                    "3Ô∏è‚É£ Predicci√≥n de Diagn√≥stico",
                    {
                        'datos_paciente': datos_paciente_prediccion,
                        'resultados_analisis': resultados_analisis,
                        'prediccion_final': prediccion_final,
                        'fig_path': temp_fig_path, # La ruta de la figura generada
                        'fs': fs_advanced_pred,
                        'ventana_duracion_seg': ventana_duracion_seg
                    },
                    pdf_buffer
                )

                st.download_button(
                    label="üìÑ Descargar Informe de Predicci√≥n PDF",
                    data=pdf_buffer.getvalue(),
                    file_name="informe_prediccion_temblor.pdf",
                    mime="application/pdf"
                )
                # Limpiar archivo temporal de gr√°fico
                if os.path.exists(temp_fig_path):
                    os.remove(temp_fig_path)

        else: # Si el modelo no se carg√≥
            st.warning("El modelo de predicci√≥n no est√° disponible. Por favor, aseg√∫rate de que el archivo 'tremor_prediction_model.joblib' est√© en la carpeta correcta y sin errores.")